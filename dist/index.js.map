{"version":3,"sources":["/home/jack/code/ytmusic-api/dist/index.js","../src/YTMusic.ts","../src/constants.ts","../src/types.ts","../node_modules/zod-to-json-schema/dist/esm/Options.js","../node_modules/zod-to-json-schema/dist/esm/Refs.js","../node_modules/zod-to-json-schema/dist/esm/errorMessages.js","../node_modules/zod-to-json-schema/dist/esm/parseDef.js","../node_modules/zod-to-json-schema/dist/esm/parsers/any.js","../node_modules/zod-to-json-schema/dist/esm/parsers/array.js","../node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js","../node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js","../node_modules/zod-to-json-schema/dist/esm/parsers/branded.js","../node_modules/zod-to-json-schema/dist/esm/parsers/catch.js","../node_modules/zod-to-json-schema/dist/esm/parsers/date.js","../node_modules/zod-to-json-schema/dist/esm/parsers/default.js","../node_modules/zod-to-json-schema/dist/esm/parsers/effects.js","../node_modules/zod-to-json-schema/dist/esm/parsers/enum.js","../node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js","../node_modules/zod-to-json-schema/dist/esm/parsers/literal.js","../node_modules/zod-to-json-schema/dist/esm/parsers/record.js","../node_modules/zod-to-json-schema/dist/esm/parsers/string.js","../node_modules/zod-to-json-schema/dist/esm/parsers/map.js","../node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js","../node_modules/zod-to-json-schema/dist/esm/parsers/never.js","../node_modules/zod-to-json-schema/dist/esm/parsers/null.js","../node_modules/zod-to-json-schema/dist/esm/parsers/union.js","../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js","../node_modules/zod-to-json-schema/dist/esm/parsers/number.js","../node_modules/zod-to-json-schema/dist/esm/parsers/object.js","../node_modules/zod-to-json-schema/dist/esm/parsers/optional.js","../node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js","../node_modules/zod-to-json-schema/dist/esm/parsers/promise.js","../node_modules/zod-to-json-schema/dist/esm/parsers/set.js","../node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js","../node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js","../node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js","../node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js","../node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js","../src/utils/checkType.ts","../src/utils/traverse.ts","../src/utils/filters.ts","../src/parsers/PlaylistParser.ts","../src/parsers/Parser.ts","../src/parsers/SongParser.ts","../src/parsers/AlbumParser.ts","../src/parsers/VideoParser.ts","../src/parsers/ArtistParser.ts","../src/parsers/SearchParser.ts","../src/index.ts"],"names":["ZodFirstPartyTypeKind","base"],"mappings":"AAAA;ACAA,4EAAqC;AACrC,2CAAkC;ADElC;AACA;AEEO,IAAM,cAAA,EAAgB,cAAA;AFA7B;AACA;AGPA,0BAAkB;AAGX,IAAM,cAAA,EAAgB,MAAA,CAC3B,MAAA,CAAO;AAAA,EACP,GAAA,EAAK,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACd,KAAA,EAAO,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EAChB,MAAA,EAAQ,MAAA,CAAE,MAAA,CAAO;AAClB,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,YAAA,EAAc,MAAA,CACzB,MAAA,CAAO;AAAA,EACP,QAAA,EAAU,MAAA,CAAE,QAAA,CAAS,MAAA,CAAE,MAAA,CAAO,CAAC,CAAA;AAAA,EAC/B,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO;AAChB,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,WAAA,EAAa,MAAA,CACxB,MAAA,CAAO;AAAA,EACP,OAAA,EAAS,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EAClB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO;AAChB,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,aAAA,EAAe,MAAA,CAC1B,MAAA,CAAO;AAAA,EACP,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,MAAM,CAAA;AAAA,EACtB,OAAA,EAAS,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EAClB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACf,MAAA,EAAQ,WAAA;AAAA,EACR,KAAA,EAAO,MAAA,CAAE,QAAA,CAAS,UAAU,CAAA;AAAA,EAC5B,QAAA,EAAU,MAAA,CAAE,QAAA,CAAS,MAAA,CAAE,MAAA,CAAO,CAAC,CAAA;AAAA,EAC/B,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa;AAClC,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,cAAA,EAAgB,MAAA,CAC3B,MAAA,CAAO;AAAA,EACP,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,OAAO,CAAA;AAAA,EACvB,OAAA,EAAS,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EAClB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACf,MAAA,EAAQ,WAAA;AAAA,EACR,QAAA,EAAU,MAAA,CAAE,QAAA,CAAS,MAAA,CAAE,MAAA,CAAO,CAAC,CAAA;AAAA,EAC/B,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa;AAClC,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,eAAA,EAAiB,MAAA,CAC5B,MAAA,CAAO;AAAA,EACP,QAAA,EAAU,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACnB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACf,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,QAAQ,CAAA;AAAA,EACxB,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa;AAClC,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,cAAA,EAAgB,MAAA,CAC3B,MAAA,CAAO;AAAA,EACP,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,OAAO,CAAA;AAAA,EACvB,OAAA,EAAS,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EAClB,UAAA,EAAY,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACrB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACf,MAAA,EAAQ,WAAA;AAAA,EACR,IAAA,EAAM,MAAA,CAAE,QAAA,CAAS,MAAA,CAAE,MAAA,CAAO,CAAC,CAAA;AAAA,EAC3B,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa;AAClC,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,iBAAA,EAAmB,MAAA,CAC9B,MAAA,CAAO;AAAA,EACP,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,UAAU,CAAA;AAAA,EAC1B,UAAA,EAAY,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACrB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACf,MAAA,EAAQ,WAAA;AAAA,EACR,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa;AAClC,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,SAAA,EAAW,MAAA,CACtB,MAAA,CAAO;AAAA,EACP,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,MAAM,CAAA;AAAA,EACtB,OAAA,EAAS,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EAClB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACf,MAAA,EAAQ,WAAA;AAAA,EACR,QAAA,EAAU,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACnB,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa,CAAA;AAAA,EACjC,OAAA,EAAS,MAAA,CAAE,KAAA,CAAM,MAAA,CAAE,GAAA,CAAI,CAAC,CAAA;AAAA,EACxB,eAAA,EAAiB,MAAA,CAAE,KAAA,CAAM,MAAA,CAAE,GAAA,CAAI,CAAC;AACjC,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,UAAA,EAAY,MAAA,CACvB,MAAA,CAAO;AAAA,EACP,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,OAAO,CAAA;AAAA,EACvB,OAAA,EAAS,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EAClB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACf,MAAA,EAAQ,WAAA;AAAA,EACR,QAAA,EAAU,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACnB,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa,CAAA;AAAA,EACjC,QAAA,EAAU,MAAA,CAAE,OAAA,CAAQ,CAAA;AAAA,EACpB,UAAA,EAAY,MAAA,CAAE,OAAA,CAAQ,CAAA;AAAA,EACtB,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,CAAA;AAAA,EAChB,IAAA,EAAM,MAAA,CAAE,KAAA,CAAM,MAAA,CAAE,MAAA,CAAO,CAAC;AACzB,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,WAAA,EAAa,MAAA,CACxB,MAAA,CAAO;AAAA,EACP,QAAA,EAAU,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACnB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACf,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,QAAQ,CAAA;AAAA,EACxB,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa,CAAA;AAAA,EACjC,QAAA,EAAU,MAAA,CAAE,KAAA,CAAM,YAAY,CAAA;AAAA,EAC9B,SAAA,EAAW,MAAA,CAAE,KAAA,CAAM,aAAa,CAAA;AAAA,EAChC,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa,CAAA;AAAA,EACjC,SAAA,EAAW,MAAA,CAAE,KAAA,CAAM,aAAa,CAAA;AAAA,EAChC,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,gBAAgB,CAAA;AAAA,EACpC,cAAA,EAAgB,MAAA,CAAE,KAAA,CAAM,cAAc;AACvC,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,UAAA,EAAY,MAAA,CACvB,MAAA,CAAO;AAAA,EACP,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,OAAO,CAAA;AAAA,EACvB,OAAA,EAAS,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EAClB,UAAA,EAAY,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACrB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACf,MAAA,EAAQ,WAAA;AAAA,EACR,IAAA,EAAM,MAAA,CAAE,QAAA,CAAS,MAAA,CAAE,MAAA,CAAO,CAAC,CAAA;AAAA,EAC3B,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa,CAAA;AAAA,EACjC,KAAA,EAAO,MAAA,CAAE,KAAA,CAAM,YAAY;AAC5B,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,aAAA,EAAe,MAAA,CAC1B,MAAA,CAAO;AAAA,EACP,IAAA,EAAM,MAAA,CAAE,OAAA,CAAQ,UAAU,CAAA;AAAA,EAC1B,UAAA,EAAY,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACrB,IAAA,EAAM,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACf,MAAA,EAAQ,WAAA;AAAA,EACR,UAAA,EAAY,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EACrB,UAAA,EAAY,MAAA,CAAE,KAAA,CAAM,aAAa;AAClC,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AAGF,IAAM,aAAA,EAAe,MAAA,CAAE,kBAAA,CAAmB,MAAA,EAAQ;AAAA,EACxD,YAAA;AAAA,EACA,aAAA;AAAA,EACA,aAAA;AAAA,EACA,cAAA;AAAA,EACA;AACD,CAAC,CAAA;AAGM,IAAM,YAAA,EAAc,MAAA,CACzB,MAAA,CAAO;AAAA,EACP,KAAA,EAAO,MAAA,CAAE,MAAA,CAAO,CAAA;AAAA,EAChB,QAAA,EAAU,MAAA,CAAE,KAAA,CAAM,MAAA,CAAE,KAAA,CAAM,CAAC,aAAA,EAAe,gBAAA,EAAkB,YAAY,CAAC,CAAC;AAC3E,CAAC,CAAA,CACA,MAAA,CAAO,CAAA;AHjDT;AACA;AI7HO,IAAM,eAAA,EAAiB,MAAA,CAAO,mDAAmD,CAAA;AACjF,IAAM,eAAA,EAAiB;AAAA,EAC1B,IAAA,EAAM,KAAA,CAAA;AAAA,EACN,YAAA,EAAc,MAAA;AAAA,EACd,QAAA,EAAU,CAAC,GAAG,CAAA;AAAA,EACd,cAAA,EAAgB,OAAA;AAAA,EAChB,YAAA,EAAc,KAAA;AAAA,EACd,YAAA,EAAc,kBAAA;AAAA,EACd,WAAA,EAAa,SAAA;AAAA,EACb,wBAAA,EAA0B,aAAA;AAAA,EAC1B,cAAA,EAAgB,aAAA;AAAA,EAChB,MAAA,EAAQ,aAAA;AAAA,EACR,YAAA,EAAc,KAAA;AAAA,EACd,WAAA,EAAa,CAAC,CAAA;AAAA,EACd,aAAA,EAAe,KAAA;AAAA,EACf,mBAAA,EAAqB,KAAA;AAAA,EACrB,eAAA,EAAiB,QAAA;AAAA,EACjB,eAAA,EAAiB,KAAA;AAAA,EACjB,aAAA,EAAe,cAAA;AAAA,EACf,cAAA,EAAgB,wBAAA;AAAA,EAChB,YAAA,EAAc;AAClB,CAAA;AACO,IAAM,kBAAA,EAAoB,CAAC,OAAA,EAAA,GAAa,OAAO,QAAA,IAAY,SAAA,EAC5D;AAAA,EACE,GAAG,cAAA;AAAA,EACH,IAAA,EAAM;AACV,EAAA,EACE;AAAA,EACE,GAAG,cAAA;AAAA,EACH,GAAG;AACP,CAAA;AJ6HJ;AACA;AK3JO,IAAM,QAAA,EAAU,CAAC,OAAA,EAAA,GAAY;AAChC,EAAA,MAAM,SAAA,EAAW,iBAAA,CAAkB,OAAO,CAAA;AAC1C,EAAA,MAAM,YAAA,EAAc,QAAA,CAAS,KAAA,IAAS,KAAA,EAAA,EAChC,CAAC,GAAG,QAAA,CAAS,QAAA,EAAU,QAAA,CAAS,cAAA,EAAgB,QAAA,CAAS,IAAI,EAAA,EAC7D,QAAA,CAAS,QAAA;AACf,EAAA,OAAO;AAAA,IACH,GAAG,QAAA;AAAA,IACH,WAAA;AAAA,IACA,YAAA,EAAc,KAAA,CAAA;AAAA,IACd,IAAA,EAAM,IAAI,GAAA,CAAI,MAAA,CAAO,OAAA,CAAQ,QAAA,CAAS,WAAW,CAAA,CAAE,GAAA,CAAI,CAAC,CAAC,IAAA,EAAM,GAAG,CAAA,EAAA,GAAM;AAAA,MACpE,GAAA,CAAI,IAAA;AAAA,MACJ;AAAA,QACI,GAAA,EAAK,GAAA,CAAI,IAAA;AAAA,QACT,IAAA,EAAM,CAAC,GAAG,QAAA,CAAS,QAAA,EAAU,QAAA,CAAS,cAAA,EAAgB,IAAI,CAAA;AAAA;AAAA,QAE1D,UAAA,EAAY,KAAA;AAAA,MAChB;AAAA,IACJ,CAAC,CAAC;AAAA,EACN,CAAA;AACJ,CAAA;AL2JA;AACA;AMhLO,SAAS,eAAA,CAAgB,GAAA,EAAK,GAAA,EAAK,YAAA,EAAc,IAAA,EAAM;AAC1D,EAAA,GAAA,CAAI,iBAAC,IAAA,6BAAM,eAAA;AACP,IAAA,MAAA;AACJ,EAAA,GAAA,CAAI,YAAA,EAAc;AACd,IAAA,GAAA,CAAI,aAAA,EAAe;AAAA,MACf,GAAG,GAAA,CAAI,YAAA;AAAA,MACP,CAAC,GAAG,CAAA,EAAG;AAAA,IACX,CAAA;AAAA,EACJ;AACJ;AACO,SAAS,yBAAA,CAA0B,GAAA,EAAK,GAAA,EAAK,KAAA,EAAO,YAAA,EAAc,IAAA,EAAM;AAC3E,EAAA,GAAA,CAAI,GAAG,EAAA,EAAI,KAAA;AACX,EAAA,eAAA,CAAgB,GAAA,EAAK,GAAA,EAAK,YAAA,EAAc,IAAI,CAAA;AAChD;ANkLA;AACA;AOhMA;APkMA;AACA;AQnMO,SAAS,WAAA,CAAA,EAAc;AAC1B,EAAA,OAAO,CAAC,CAAA;AACZ;ARqMA;AACA;ASxMA;AAGO,SAAS,aAAA,CAAc,GAAA,EAAK,IAAA,EAAM;AACrC,EAAA,MAAM,IAAA,EAAM;AAAA,IACR,IAAA,EAAM;AAAA,EACV,CAAA;AACA,EAAA,GAAA,iBAAI,GAAA,qBAAI,IAAA,6BAAM,IAAA,6BAAM,WAAA,IAAa,0BAAA,CAAsB,MAAA,EAAQ;AAC3D,IAAA,GAAA,CAAI,MAAA,EAAQ,QAAA,CAAS,GAAA,CAAI,IAAA,CAAK,IAAA,EAAM;AAAA,MAChC,GAAG,IAAA;AAAA,MACH,WAAA,EAAa,CAAC,GAAG,IAAA,CAAK,WAAA,EAAa,OAAO;AAAA,IAC9C,CAAC,CAAA;AAAA,EACL;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,SAAA,EAAW;AACf,IAAA,yBAAA,CAA0B,GAAA,EAAK,UAAA,EAAY,GAAA,CAAI,SAAA,CAAU,KAAA,EAAO,GAAA,CAAI,SAAA,CAAU,OAAA,EAAS,IAAI,CAAA;AAAA,EAC/F;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,SAAA,EAAW;AACf,IAAA,yBAAA,CAA0B,GAAA,EAAK,UAAA,EAAY,GAAA,CAAI,SAAA,CAAU,KAAA,EAAO,GAAA,CAAI,SAAA,CAAU,OAAA,EAAS,IAAI,CAAA;AAAA,EAC/F;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,WAAA,EAAa;AACjB,IAAA,yBAAA,CAA0B,GAAA,EAAK,UAAA,EAAY,GAAA,CAAI,WAAA,CAAY,KAAA,EAAO,GAAA,CAAI,WAAA,CAAY,OAAA,EAAS,IAAI,CAAA;AAC/F,IAAA,yBAAA,CAA0B,GAAA,EAAK,UAAA,EAAY,GAAA,CAAI,WAAA,CAAY,KAAA,EAAO,GAAA,CAAI,WAAA,CAAY,OAAA,EAAS,IAAI,CAAA;AAAA,EACnG;AACA,EAAA,OAAO,GAAA;AACX;ATwMA;AACA;AUhOO,SAAS,cAAA,CAAe,GAAA,EAAK,IAAA,EAAM;AACtC,EAAA,MAAM,IAAA,EAAM;AAAA,IACR,IAAA,EAAM,SAAA;AAAA,IACN,MAAA,EAAQ;AAAA,EACZ,CAAA;AACA,EAAA,GAAA,CAAI,CAAC,GAAA,CAAI,MAAA;AACL,IAAA,OAAO,GAAA;AACX,EAAA,IAAA,CAAA,MAAW,MAAA,GAAS,GAAA,CAAI,MAAA,EAAQ;AAC5B,IAAA,OAAA,CAAQ,KAAA,CAAM,IAAA,EAAM;AAAA,MAChB,KAAK,KAAA;AACD,QAAA,GAAA,CAAI,IAAA,CAAK,OAAA,IAAW,aAAA,EAAe;AAC/B,UAAA,GAAA,CAAI,KAAA,CAAM,SAAA,EAAW;AACjB,YAAA,yBAAA,CAA0B,GAAA,EAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAAA,UAC9E,EAAA,KACK;AACD,YAAA,yBAAA,CAA0B,GAAA,EAAK,kBAAA,EAAoB,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAAA,UACvF;AAAA,QACJ,EAAA,KACK;AACD,UAAA,GAAA,CAAI,CAAC,KAAA,CAAM,SAAA,EAAW;AAClB,YAAA,GAAA,CAAI,iBAAA,EAAmB,IAAA;AAAA,UAC3B;AACA,UAAA,yBAAA,CAA0B,GAAA,EAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAAA,QAC9E;AACA,QAAA,KAAA;AAAA,MACJ,KAAK,KAAA;AACD,QAAA,GAAA,CAAI,IAAA,CAAK,OAAA,IAAW,aAAA,EAAe;AAC/B,UAAA,GAAA,CAAI,KAAA,CAAM,SAAA,EAAW;AACjB,YAAA,yBAAA,CAA0B,GAAA,EAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAAA,UAC9E,EAAA,KACK;AACD,YAAA,yBAAA,CAA0B,GAAA,EAAK,kBAAA,EAAoB,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAAA,UACvF;AAAA,QACJ,EAAA,KACK;AACD,UAAA,GAAA,CAAI,CAAC,KAAA,CAAM,SAAA,EAAW;AAClB,YAAA,GAAA,CAAI,iBAAA,EAAmB,IAAA;AAAA,UAC3B;AACA,UAAA,yBAAA,CAA0B,GAAA,EAAK,SAAA,EAAW,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAAA,QAC9E;AACA,QAAA,KAAA;AAAA,MACJ,KAAK,YAAA;AACD,QAAA,yBAAA,CAA0B,GAAA,EAAK,YAAA,EAAc,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAC7E,QAAA,KAAA;AAAA,IACR;AAAA,EACJ;AACA,EAAA,OAAO,GAAA;AACX;AV8NA;AACA;AW/QO,SAAS,eAAA,CAAA,EAAkB;AAC9B,EAAA,OAAO;AAAA,IACH,IAAA,EAAM;AAAA,EACV,CAAA;AACJ;AXiRA;AACA;AYrRO,SAAS,eAAA,CAAgB,IAAA,EAAM,IAAA,EAAM;AACxC,EAAA,OAAO,QAAA,CAAS,IAAA,CAAK,IAAA,CAAK,IAAA,EAAM,IAAI,CAAA;AACxC;AZuRA;AACA;Aa1RO,IAAM,cAAA,EAAgB,CAAC,GAAA,EAAK,IAAA,EAAA,GAAS;AACxC,EAAA,OAAO,QAAA,CAAS,GAAA,CAAI,SAAA,CAAU,IAAA,EAAM,IAAI,CAAA;AAC5C,CAAA;Ab4RA;AACA;Ac/RO,SAAS,YAAA,CAAa,GAAA,EAAK,IAAA,EAAM,oBAAA,EAAsB;AAC1D,EAAA,MAAM,SAAA,mBAAW,oBAAA,UAAwB,IAAA,CAAK,cAAA;AAC9C,EAAA,GAAA,CAAI,KAAA,CAAM,OAAA,CAAQ,QAAQ,CAAA,EAAG;AACzB,IAAA,OAAO;AAAA,MACH,KAAA,EAAO,QAAA,CAAS,GAAA,CAAI,CAAC,IAAA,EAAM,CAAA,EAAA,GAAM,YAAA,CAAa,GAAA,EAAK,IAAA,EAAM,IAAI,CAAC;AAAA,IAClE,CAAA;AAAA,EACJ;AACA,EAAA,OAAA,CAAQ,QAAA,EAAU;AAAA,IACd,KAAK,QAAA;AAAA,IACL,KAAK,kBAAA;AACD,MAAA,OAAO;AAAA,QACH,IAAA,EAAM,QAAA;AAAA,QACN,MAAA,EAAQ;AAAA,MACZ,CAAA;AAAA,IACJ,KAAK,aAAA;AACD,MAAA,OAAO;AAAA,QACH,IAAA,EAAM,QAAA;AAAA,QACN,MAAA,EAAQ;AAAA,MACZ,CAAA;AAAA,IACJ,KAAK,SAAA;AACD,MAAA,OAAO,iBAAA,CAAkB,GAAA,EAAK,IAAI,CAAA;AAAA,EAC1C;AACJ;AACA,IAAM,kBAAA,EAAoB,CAAC,GAAA,EAAK,IAAA,EAAA,GAAS;AACrC,EAAA,MAAM,IAAA,EAAM;AAAA,IACR,IAAA,EAAM,SAAA;AAAA,IACN,MAAA,EAAQ;AAAA,EACZ,CAAA;AACA,EAAA,GAAA,CAAI,IAAA,CAAK,OAAA,IAAW,UAAA,EAAY;AAC5B,IAAA,OAAO,GAAA;AAAA,EACX;AACA,EAAA,IAAA,CAAA,MAAW,MAAA,GAAS,GAAA,CAAI,MAAA,EAAQ;AAC5B,IAAA,OAAA,CAAQ,KAAA,CAAM,IAAA,EAAM;AAAA,MAChB,KAAK,KAAA;AACD,QAAA,yBAAA;AAAA,UAA0B,GAAA;AAAA,UAAK,SAAA;AAAA,UAAW,KAAA,CAAM,KAAA;AAAA;AAAA,UAChD,KAAA,CAAM,OAAA;AAAA,UAAS;AAAA,QAAI,CAAA;AACnB,QAAA,KAAA;AAAA,MACJ,KAAK,KAAA;AACD,QAAA,yBAAA;AAAA,UAA0B,GAAA;AAAA,UAAK,SAAA;AAAA,UAAW,KAAA,CAAM,KAAA;AAAA;AAAA,UAChD,KAAA,CAAM,OAAA;AAAA,UAAS;AAAA,QAAI,CAAA;AACnB,QAAA,KAAA;AAAA,IACR;AAAA,EACJ;AACA,EAAA,OAAO,GAAA;AACX,CAAA;Ad6SA;AACA;Ae1VO,SAAS,eAAA,CAAgB,IAAA,EAAM,IAAA,EAAM;AACxC,EAAA,OAAO;AAAA,IACH,GAAG,QAAA,CAAS,IAAA,CAAK,SAAA,CAAU,IAAA,EAAM,IAAI,CAAA;AAAA,IACrC,OAAA,EAAS,IAAA,CAAK,YAAA,CAAa;AAAA,EAC/B,CAAA;AACJ;Af4VA;AACA;AgBlWO,SAAS,eAAA,CAAgB,IAAA,EAAM,IAAA,EAAM;AACxC,EAAA,OAAO,IAAA,CAAK,eAAA,IAAmB,QAAA,EACzB,QAAA,CAAS,IAAA,CAAK,MAAA,CAAO,IAAA,EAAM,IAAI,EAAA,EAC/B,CAAC,CAAA;AACX;AhBkWA;AACA;AiBxWO,SAAS,YAAA,CAAa,GAAA,EAAK;AAC9B,EAAA,OAAO;AAAA,IACH,IAAA,EAAM,QAAA;AAAA,IACN,IAAA,EAAM,GAAA,CAAI;AAAA,EACd,CAAA;AACJ;AjB0WA;AACA;AkB/WA,IAAM,uBAAA,EAAyB,CAAC,IAAA,EAAA,GAAS;AACrC,EAAA,GAAA,CAAI,OAAA,GAAU,KAAA,GAAQ,IAAA,CAAK,KAAA,IAAS,QAAA;AAChC,IAAA,OAAO,KAAA;AACX,EAAA,OAAO,QAAA,GAAW,IAAA;AACtB,CAAA;AACO,SAAS,oBAAA,CAAqB,GAAA,EAAK,IAAA,EAAM;AAC5C,EAAA,MAAM,MAAA,EAAQ;AAAA,IACV,QAAA,CAAS,GAAA,CAAI,IAAA,CAAK,IAAA,EAAM;AAAA,MACpB,GAAG,IAAA;AAAA,MACH,WAAA,EAAa,CAAC,GAAG,IAAA,CAAK,WAAA,EAAa,OAAA,EAAS,GAAG;AAAA,IACnD,CAAC,CAAA;AAAA,IACD,QAAA,CAAS,GAAA,CAAI,KAAA,CAAM,IAAA,EAAM;AAAA,MACrB,GAAG,IAAA;AAAA,MACH,WAAA,EAAa,CAAC,GAAG,IAAA,CAAK,WAAA,EAAa,OAAA,EAAS,GAAG;AAAA,IACnD,CAAC;AAAA,EACL,CAAA,CAAE,MAAA,CAAO,CAAC,CAAA,EAAA,GAAM,CAAC,CAAC,CAAC,CAAA;AACnB,EAAA,IAAI,sBAAA,EAAwB,IAAA,CAAK,OAAA,IAAW,oBAAA,EACtC,EAAE,qBAAA,EAAuB,MAAM,EAAA,EAC/B,KAAA,CAAA;AACN,EAAA,MAAM,YAAA,EAAc,CAAC,CAAA;AAErB,EAAA,KAAA,CAAM,OAAA,CAAQ,CAAC,MAAA,EAAA,GAAW;AACtB,IAAA,GAAA,CAAI,sBAAA,CAAuB,MAAM,CAAA,EAAG;AAChC,MAAA,WAAA,CAAY,IAAA,CAAK,GAAG,MAAA,CAAO,KAAK,CAAA;AAChC,MAAA,GAAA,CAAI,MAAA,CAAO,sBAAA,IAA0B,KAAA,CAAA,EAAW;AAG5C,QAAA,sBAAA,EAAwB,KAAA,CAAA;AAAA,MAC5B;AAAA,IACJ,EAAA,KACK;AACD,MAAA,IAAI,aAAA,EAAe,MAAA;AACnB,MAAA,GAAA,CAAI,uBAAA,GAA0B,OAAA,GAC1B,MAAA,CAAO,qBAAA,IAAyB,KAAA,EAAO;AACvC,QAAA,MAAM,EAAE,oBAAA,EAAsB,GAAG,KAAK,EAAA,EAAI,MAAA;AAC1C,QAAA,aAAA,EAAe,IAAA;AAAA,MACnB,EAAA,KACK;AAED,QAAA,sBAAA,EAAwB,KAAA,CAAA;AAAA,MAC5B;AACA,MAAA,WAAA,CAAY,IAAA,CAAK,YAAY,CAAA;AAAA,IACjC;AAAA,EACJ,CAAC,CAAA;AACD,EAAA,OAAO,WAAA,CAAY,OAAA,EACb;AAAA,IACE,KAAA,EAAO,WAAA;AAAA,IACP,GAAG;AAAA,EACP,EAAA,EACE,KAAA,CAAA;AACV;AlBsWA;AACA;AmB1ZO,SAAS,eAAA,CAAgB,GAAA,EAAK,IAAA,EAAM;AACvC,EAAA,MAAM,WAAA,EAAa,OAAO,GAAA,CAAI,KAAA;AAC9B,EAAA,GAAA,CAAI,WAAA,IAAe,SAAA,GACf,WAAA,IAAe,SAAA,GACf,WAAA,IAAe,UAAA,GACf,WAAA,IAAe,QAAA,EAAU;AACzB,IAAA,OAAO;AAAA,MACH,IAAA,EAAM,KAAA,CAAM,OAAA,CAAQ,GAAA,CAAI,KAAK,EAAA,EAAI,QAAA,EAAU;AAAA,IAC/C,CAAA;AAAA,EACJ;AACA,EAAA,GAAA,CAAI,IAAA,CAAK,OAAA,IAAW,UAAA,EAAY;AAC5B,IAAA,OAAO;AAAA,MACH,IAAA,EAAM,WAAA,IAAe,SAAA,EAAW,UAAA,EAAY,UAAA;AAAA,MAC5C,IAAA,EAAM,CAAC,GAAA,CAAI,KAAK;AAAA,IACpB,CAAA;AAAA,EACJ;AACA,EAAA,OAAO;AAAA,IACH,IAAA,EAAM,WAAA,IAAe,SAAA,EAAW,UAAA,EAAY,UAAA;AAAA,IAC5C,KAAA,EAAO,GAAA,CAAI;AAAA,EACf,CAAA;AACJ;AnByZA;AACA;AoB9aA;ApBgbA;AACA;AqBhbA,IAAI,UAAA;AAOG,IAAM,YAAA,EAAc;AAAA;AAAA;AAAA;AAAA,EAIvB,IAAA,EAAM,kBAAA;AAAA,EACN,KAAA,EAAO,aAAA;AAAA,EACP,IAAA,EAAM,0BAAA;AAAA;AAAA;AAAA;AAAA,EAIN,KAAA,EAAO,kGAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYP,KAAA,EAAO,CAAA,EAAA,GAAM;AACT,IAAA,GAAA,CAAI,WAAA,IAAe,KAAA,CAAA,EAAW;AAC1B,MAAA,WAAA,EAAa,MAAA,CAAO,sDAAA,EAAwD,GAAG,CAAA;AAAA,IACnF;AACA,IAAA,OAAO,UAAA;AAAA,EACX,CAAA;AAAA;AAAA;AAAA;AAAA,EAIA,IAAA,EAAM,uFAAA;AAAA;AAAA;AAAA;AAAA,EAIN,IAAA,EAAM,qHAAA;AAAA;AAAA;AAAA;AAAA,EAIN,IAAA,EAAM,8XAAA;AAAA,EACN,MAAA,EAAQ,kEAAA;AAAA,EACR,MAAA,EAAQ;AACZ,CAAA;AACO,SAAS,cAAA,CAAe,GAAA,EAAK,IAAA,EAAM;AACtC,EAAA,MAAM,IAAA,EAAM;AAAA,IACR,IAAA,EAAM;AAAA,EACV,CAAA;AACA,EAAA,SAAS,cAAA,CAAe,KAAA,EAAO;AAC3B,IAAA,OAAO,IAAA,CAAK,gBAAA,IAAoB,SAAA,EAC1B,qBAAA,CAAsB,KAAK,EAAA,EAC3B,KAAA;AAAA,EACV;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,MAAA,EAAQ;AACZ,IAAA,IAAA,CAAA,MAAW,MAAA,GAAS,GAAA,CAAI,MAAA,EAAQ;AAC5B,MAAA,OAAA,CAAQ,KAAA,CAAM,IAAA,EAAM;AAAA,QAChB,KAAK,KAAA;AACD,UAAA,yBAAA,CAA0B,GAAA,EAAK,WAAA,EAAa,OAAO,GAAA,CAAI,UAAA,IAAc,SAAA,EAC/D,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,SAAA,EAAW,KAAA,CAAM,KAAK,EAAA,EACnC,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AACtC,UAAA,KAAA;AAAA,QACJ,KAAK,KAAA;AACD,UAAA,yBAAA,CAA0B,GAAA,EAAK,WAAA,EAAa,OAAO,GAAA,CAAI,UAAA,IAAc,SAAA,EAC/D,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,SAAA,EAAW,KAAA,CAAM,KAAK,EAAA,EACnC,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AACtC,UAAA,KAAA;AAAA,QACJ,KAAK,OAAA;AACD,UAAA,OAAA,CAAQ,IAAA,CAAK,aAAA,EAAe;AAAA,YACxB,KAAK,cAAA;AACD,cAAA,SAAA,CAAU,GAAA,EAAK,OAAA,EAAS,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAC3C,cAAA,KAAA;AAAA,YACJ,KAAK,kBAAA;AACD,cAAA,SAAA,CAAU,GAAA,EAAK,WAAA,EAAa,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAC/C,cAAA,KAAA;AAAA,YACJ,KAAK,aAAA;AACD,cAAA,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AACtD,cAAA,KAAA;AAAA,UACR;AACA,UAAA,KAAA;AAAA,QACJ,KAAK,KAAA;AACD,UAAA,SAAA,CAAU,GAAA,EAAK,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AACzC,UAAA,KAAA;AAAA,QACJ,KAAK,MAAA;AACD,UAAA,SAAA,CAAU,GAAA,EAAK,MAAA,EAAQ,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAC1C,UAAA,KAAA;AAAA,QACJ,KAAK,OAAA;AACD,UAAA,UAAA,CAAW,GAAA,EAAK,KAAA,CAAM,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AAChD,UAAA,KAAA;AAAA,QACJ,KAAK,MAAA;AACD,UAAA,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,IAAA,EAAM,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AACrD,UAAA,KAAA;AAAA,QACJ,KAAK,OAAA;AACD,UAAA,UAAA,CAAW,GAAA,EAAK,WAAA,CAAY,KAAA,EAAO,KAAA,CAAM,OAAA,EAAS,IAAI,CAAA;AACtD,UAAA,KAAA;AAAA,QACJ,KAAK,YAAA;AACD,UAAA,UAAA,CAAW,GAAA,EAAK,MAAA,CAAO,CAAA,CAAA,EAAI,cAAA,CAAe,KAAA,CAAM,KAAK,CAAC,CAAA,CAAA;AACtD,UAAA;AACC,QAAA;AACoD,UAAA;AACrD,UAAA;AACC,QAAA;AAC8C,UAAA;AAC/C,UAAA;AACC,QAAA;AACyC,UAAA;AAC1C,UAAA;AACC,QAAA;AACyC,UAAA;AAC1C,UAAA;AACC,QAAA;AAC6C,UAAA;AAC9C,UAAA;AACC,QAAA;AACsD,UAAA;AAGA,UAAA;AAGvD,UAAA;AACa,QAAA;AACwC,UAAA;AACrD,UAAA;AACJ,QAAA;AACW,QAAA;AACqB,UAAA;AACkB,YAAA;AAC9C,UAAA;AAC4B,UAAA;AACkB,YAAA;AAC9C,UAAA;AACA,UAAA;AACJ,QAAA;AACK,QAAA;AACqD,UAAA;AACtD,UAAA;AACS,QAAA;AAC4C,UAAA;AACrD,UAAA;AACJ,QAAA;AACe,QAAA;AACkB,UAAA;AACH,YAAA;AAC0B,cAAA;AAC5C,cAAA;AACJ,YAAA;AAC+B,YAAA;AACuB,cAAA;AAClD,cAAA;AACJ,YAAA;AACoB,YAAA;AACmC,cAAA;AACnD,cAAA;AACJ,YAAA;AACJ,UAAA;AACA,UAAA;AACJ,QAAA;AACe,QAAA;AAC4C,UAAA;AAC3D,QAAA;AACK,QAAA;AACA,QAAA;AACA,QAAA;AACD,UAAA;AACJ,QAAA;AACY,0BAAA;AAAU,UAAA;AAC1B,MAAA;AACJ,IAAA;AACJ,EAAA;AACO,EAAA;AACX;AAEU;AAE0C;AACU,EAAA;AACnC,IAAA;AACC,MAAA;AACpB,IAAA;AACmB,IAAA;AACG,MAAA;AACC,QAAA;AAEW,QAAA;AAC6B,UAAA;AACvD,QAAA;AACH,MAAA;AACa,MAAA;AACW,MAAA;AACM,QAAA;AACwB,QAAA;AACjC,UAAA;AAClB,QAAA;AACJ,MAAA;AACJ,IAAA;AACkB,IAAA;AACN,MAAA;AAEoC,MAAA;AAC/C,IAAA;AAEA,EAAA;AAC2D,IAAA;AAChE,EAAA;AACJ;AACqD;AACW,EAAA;AACrC,IAAA;AACC,MAAA;AACpB,IAAA;AACoB,IAAA;AACE,MAAA;AACE,QAAA;AAEU,QAAA;AAC+B,UAAA;AACzD,QAAA;AACH,MAAA;AACa,MAAA;AACW,MAAA;AACM,QAAA;AACwB,QAAA;AACjC,UAAA;AAClB,QAAA;AACJ,MAAA;AACJ,IAAA;AACkB,IAAA;AACoB,MAAA;AAEU,MAAA;AAC/C,IAAA;AAEA,EAAA;AAC0D,IAAA;AAC/D,EAAA;AACJ;AAEiD;AACS,EAAA;AAClB,EAAA;AACnB,IAAA;AAEH,EAAA;AACiB,IAAA;AACA,IAAA;AACA,IAAA;AAAA;AAC/B,EAAA;AAE4D,EAAA;AAC9C,EAAA;AACE,EAAA;AACE,EAAA;AACA,EAAA;AACsB,EAAA;AACrB,IAAA;AACQ,MAAA;AACP,MAAA;AACZ,MAAA;AACJ,IAAA;AACa,IAAA;AACQ,MAAA;AACiB,QAAA;AACT,UAAA;AACM,YAAA;AACwB,YAAA;AAC7B,YAAA;AAE+B,UAAA;AAC1B,YAAA;AACL,YAAA;AAEb,UAAA;AACgD,YAAA;AACrD,UAAA;AACA,UAAA;AACJ,QAAA;AAE+B,MAAA;AACmB,QAAA;AAClD,QAAA;AACJ,MAAA;AACJ,IAAA;AACa,IAAA;AACc,MAAA;AACR,QAAA;AAAA,GAAA;AACX,QAAA;AAEwB,MAAA;AACb,QAAA;AAAA,GAAA;AACX,QAAA;AACJ,MAAA;AACJ,IAAA;AACkC,IAAA;AACO,MAAA;AAAsB;AAAA,CAAA;AAC3D,MAAA;AACJ,IAAA;AACmB,IAAA;AACK,IAAA;AACR,MAAA;AAE2B,IAAA;AACzB,MAAA;AAE0B,IAAA;AAC1B,MAAA;AAClB,IAAA;AACJ,EAAA;AACI,EAAA;AACoC,IAAA;AAElC,EAAA;AACsD,IAAA;AAC3C,IAAA;AACjB,EAAA;AACO,EAAA;AACX;ArBsZiE;AACA;AoBttBvB;AAEhB,EAAA;AACX,IAAA;AACG,MAAA;AACqB,MAAA;AAC+B,MAAA;AACnD,QAAA;AACiC,QAAA;AAC7B,UAAA;AACiD,UAAA;AACjD,QAAA;AACL,MAAA;AACgB,MAAA;AAC1B,IAAA;AACJ,EAAA;AACe,EAAA;AACL,IAAA;AAC6C,IAAA;AAC5C,MAAA;AACsD,MAAA;AACtD,IAAA;AACX,EAAA;AACgC,EAAA;AACrB,IAAA;AACX,EAAA;AACyD,EAAA;AAEK,IAAA;AACnD,IAAA;AACA,MAAA;AACY,MAAA;AACnB,IAAA;AAEoCA,EAAAA;AAC7B,IAAA;AACA,MAAA;AACY,MAAA;AACY,QAAA;AAC3B,MAAA;AACJ,IAAA;AACJ,EAAA;AACO,EAAA;AACX;ApBqtBiE;AACA;AsBlwB1B;AACA,EAAA;AACA,IAAA;AACnC,EAAA;AACwC,EAAA;AACjC,IAAA;AACqD,IAAA;AACrD,EAAA;AACqC,EAAA;AACrC,IAAA;AACqD,IAAA;AACrD,EAAA;AACA,EAAA;AACG,IAAA;AACI,IAAA;AACH,IAAA;AACG,MAAA;AACc,MAAA;AACV,MAAA;AACA,MAAA;AACd,IAAA;AACJ,EAAA;AACJ;AtBowBiE;AACA;AuB7xBzB;AACjB,EAAA;AACwC,EAAA;AACjB,IAAA;AACzC,EAAA;AACuD,EAAA;AACC,EAAA;AAClD,EAAA;AAEsB,IAAA;AAInB,IAAA;AACV,EAAA;AACJ;AvB2xBiE;AACA;AwB3yBjC;AACrB,EAAA;AACG,IAAA;AACV,EAAA;AACJ;AxB6yBiE;AACA;AyBlzB9B;AAEzB,EAAA;AACe,IAAA;AACH,IAAA;AAEZ,EAAA;AACQ,IAAA;AACV,EAAA;AACR;AzBkzBiE;AACA;A0B3zBhC;AAClB,EAAA;AACA,EAAA;AACA,EAAA;AACC,EAAA;AACH,EAAA;AACb;AACyC;AACjB,EAAA;AACQ,IAAA;AACgC,EAAA;AAEhB,EAAA;AAGG,IAAA;AACO,MAAA;AACQ,MAAA;AACrD,IAAA;AACE,IAAA;AACqC,MAAA;AAC5C,IAAA;AAE8C,EAAA;AAEL,IAAA;AACV,MAAA;AACb,MAAA;AACL,QAAA;AACA,QAAA;AACA,QAAA;AACmB,UAAA;AACnB,QAAA;AACwB,UAAA;AACxB,QAAA;AACoB,UAAA;AACK,YAAA;AACzB,QAAA;AACA,QAAA;AACA,QAAA;AACL,QAAA;AACW,UAAA;AACf,MAAA;AACC,IAAA;AACgC,IAAA;AAEwB,MAAA;AAClD,MAAA;AACsD,QAAA;AACxB,QAAA;AACwB,UAAA;AACpD,QAAA;AACT,MAAA;AACJ,IAAA;AAEuD,EAAA;AAChD,IAAA;AACG,MAAA;AAC2B,MAAA;AAC1B,QAAA;AAC4C,QAAA;AAC9C,MAAA;AACT,IAAA;AACJ,EAAA;AACwB,EAAA;AAC5B;AAC+B;AAEN,EAAA;AAGd,IAAA;AAC+C,IAAA;AAIhC,EAAA;AACY,EAAA;AACtC;A1BgzBiE;AACA;A2B93BrB;AACkB,EAAA;AAEtB,IAAA;AACrB,MAAA;AACgD,QAAA;AACzC,QAAA;AACd,MAAA;AACJ,IAAA;AACO,IAAA;AACG,MAAA;AAC2C,QAAA;AAC7C,QAAA;AACJ,MAAA;AACJ,IAAA;AACJ,EAAA;AACgC,EAAA;AACc,IAAA;AACnC,MAAA;AAC8B,MAAA;AACpC,IAAA;AACqBC,IAAAA;AACqB,MAAA;AACF,IAAA;AAC7C,EAAA;AAC0C,EAAA;AACnC,IAAA;AAC4C,IAAA;AAClD,EAAA;AACgD,EAAA;AACrD;A3B+3BiE;AACA;A4B/5BvB;AAC1B,EAAA;AACF,IAAA;AACV,EAAA;AACS,EAAA;AACE,IAAA;AACqB,EAAA;AACR,IAAA;AACX,MAAA;AACU,QAAA;AACqC,QAAA;AAChD,QAAA;AACC,MAAA;AACkC,QAAA;AACV,UAAA;AAC+B,YAAA;AAE/C,UAAA;AACkD,YAAA;AACvD,UAAA;AAEC,QAAA;AACqB,UAAA;AACK,YAAA;AAC3B,UAAA;AACuD,UAAA;AAC3D,QAAA;AACA,QAAA;AACC,MAAA;AACkC,QAAA;AACV,UAAA;AAC+B,YAAA;AAE/C,UAAA;AACkD,YAAA;AACvD,UAAA;AAEC,QAAA;AACqB,UAAA;AACK,YAAA;AAC3B,UAAA;AACuD,UAAA;AAC3D,QAAA;AACA,QAAA;AACC,MAAA;AACkD,QAAA;AACnD,QAAA;AACR,IAAA;AACJ,EAAA;AACO,EAAA;AACX;A5B65BiE;AACA;A6Bh9BlB;AACK,EAAA;AAElC,IAAA;AAEC,MAAA;AACsD,MAAA;AACvD,IAAA;AAET,EAAA;AAES,IAAA;AAEC,MAAA;AACsD,MAAA;AACvD,IAAA;AACd,EAAA;AACJ;AAsD0C;AACvB,EAAA;AACL,IAAA;AACiD,IAAA;AACL,MAAA;AACnC,QAAA;AAC8B,MAAA;AAClC,QAAA;AACsD,QAAA;AACP,QAAA;AACrD,MAAA;AACiB,MAAA;AACP,QAAA;AACJ,MAAA;AACoD,QAAA;AAGzC,QAAA;AAClB,MAAA;AAC+B,IAAA;AACuB,IAAA;AAC9D,EAAA;AACqB,EAAA;AACH,IAAA;AACX,EAAA;AACX;A7Bs5BiE;AACA;A8Bv/BlB;AACY,EAAA;AACX,IAAA;AAC5C,EAAA;AACiD,EAAA;AAC1C,IAAA;AAC4C,IAAA;AAClD,EAAA;AAEK,EAAA;AACS,IAAA;AACH,MAAA;AACU,QAAA;AACV,MAAA;AACA,MAAA;AACJ,IAAA;AAED,EAAA;AACX;A9Bu/BiE;AACA;A+B1gClB;AACR,EAAA;AACE,IAAA;AAEI,EAAA;AACH,IAAA;AACtC,EAAA;AACgC,EAAA;AACzB,IAAA;AAC4C,IAAA;AAClD,EAAA;AACgC,EAAA;AAC1B,IAAA;AACsD,IAAA;AAC5D,EAAA;AACM,EAAA;AACwC,IAAA;AAC/C,EAAA;AACJ;A/B2gCiE;AACA;AgC9hCtB;AACJ,EAAA;AACvC;AhCgiCiE;AACA;AiCliC1B;AACQ,EAAA;AACpC,IAAA;AACuC,IAAA;AAC7C,EAAA;AACc,EAAA;AACL,IAAA;AACO,IAAA;AACb,IAAA;AACJ,EAAA;AACiB,EAAA;AAC6C,IAAA;AAC9D,EAAA;AACiB,EAAA;AAC6C,IAAA;AAC9D,EAAA;AACO,EAAA;AACX;AjCoiCiE;AACA;AkCvjCxB;AACvB,EAAA;AACH,IAAA;AACG,MAAA;AACc,MAAA;AAEgB,MAAA;AAC7B,QAAA;AAC+C,QAAA;AAEW,MAAA;AACxB,MAAA;AAClC,QAAA;AACiD,QAAA;AACvD,MAAA;AACL,IAAA;AAEC,EAAA;AACM,IAAA;AACG,MAAA;AACc,MAAA;AACA,MAAA;AAEgB,MAAA;AAC7B,QAAA;AAC+C,QAAA;AAEW,MAAA;AACrE,IAAA;AACJ,EAAA;AACJ;AlCojCiE;AACA;AmCplC7B;AACzB,EAAA;AACG,IAAA;AACV,EAAA;AACJ;AnCslCiE;AACA;AoC3lC/B;AACtB,EAAA;AACZ;ApC6lCiE;AACA;AqC/lClB;AACH,EAAA;AAC5C;ArCimCiE;AACA;AOrkCJ;AACvB,EAAA;AACf,EAAA;AAC6C,IAAA;AACrB,IAAA;AAC5B,MAAA;AACX,IAAA;AACJ,EAAA;AACkC,EAAA;AACW,IAAA;AACX,IAAA;AACnB,MAAA;AACX,IAAA;AACJ,EAAA;AAC2D,EAAA;AACjC,EAAA;AAC6B,EAAA;AACvC,EAAA;AACiB,IAAA;AACjC,EAAA;AACqB,EAAA;AACd,EAAA;AACX;AACgC;AACD,EAAA;AAClB,IAAA;AACkC,MAAA;AAClC,IAAA;AACyD,MAAA;AACzD,IAAA;AACQ,IAAA;AAEA,MAAA;AACgD,QAAA;AAC7C,QAAA;AACZ,MAAA;AAC2C,MAAA;AAC/C,IAAA;AACJ,EAAA;AACJ;AAC0C;AAC9B,EAAA;AAC0C,EAAA;AACtB,IAAA;AACpB,MAAA;AACR,EAAA;AAC+D,EAAA;AACnE;AAC8C;AACxB,EAAA;AACa,IAAA;AACQ,MAAA;AACR,IAAA;AACQ,MAAA;AACR,IAAA;AACQ,MAAA;AACR,IAAA;AACQ,MAAA;AACR,IAAA;AACA,MAAA;AACA,IAAA;AACM,MAAA;AACN,IAAA;AACE,MAAA;AACF,IAAA;AACC,MAAA;AACD,IAAA;AACO,MAAA;AACP,IAAA;AACA,IAAA;AACO,MAAA;AACP,IAAA;AACc,MAAA;AACd,IAAA;AACO,MAAA;AACP,IAAA;AACQ,MAAA;AACR,IAAA;AACS,MAAA;AACT,IAAA;AACA,MAAA;AACA,IAAA;AACM,MAAA;AACN,IAAA;AACU,MAAA;AACV,IAAA;AACU,MAAA;AACV,IAAA;AACK,MAAA;AACL,IAAA;AACK,MAAA;AACL,IAAA;AACgB,MAAA;AAChB,IAAA;AACS,MAAA;AACT,IAAA;AACA,IAAA;AACF,MAAA;AACE,IAAA;AACS,MAAA;AACT,IAAA;AACJ,MAAA;AACI,IAAA;AACA,MAAA;AACA,IAAA;AACS,MAAA;AACT,IAAA;AACS,MAAA;AACT,IAAA;AACU,MAAA;AACV,IAAA;AACO,MAAA;AACP,IAAA;AACU,MAAA;AACV,IAAA;AACA,IAAA;AACA,IAAA;AAChB,MAAA;AACX,IAAA;AACsC,MAAA;AAC1C,EAAA;AACJ;AAC2C;AAClB,EAAA;AACY,IAAA;AACC,IAAA;AACW,MAAA;AACzC,IAAA;AACJ,EAAA;AACO,EAAA;AACX;APskCiE;AACA;AsCvuCpB;AACb,EAAA;AAC+B,EAAA;AAEhD,IAAA;AAC2B,IAAA;AACvB,MAAA;AACsD,MAAA;AAChD,IAAA;AAEf,EAAA;AAGS,EAAA;AAKT,EAAA;AACK,IAAA;AACsD,IAAA;AAC/C,EAAA;AAEG,EAAA;AAII,EAAA;AACR,IAAA;AACjB,EAAA;AAGU,EAAA;AACK,IAAA;AACoB,IAAA;AAG7B,EAAA;AACQ,IAAA;AAC+C,MAAA;AAC5C,MAAA;AACL,MAAA;AACM,IAAA;AACa,IAAA;AAChB,MAAA;AACK,MAAA;AACZ,IAAA;AACJ,EAAA;AAC+B,EAAA;AACZ,IAAA;AAEuB,EAAA;AACvB,IAAA;AACvB,EAAA;AACO,EAAA;AACX;AtCwtCiE;AACA;AuC/wCb;AACjB,EAAA;AAEhB,EAAA;AACT,IAAA;AACP,MAAA;AACK,MAAA;AACJ,QAAA;AACC,UAAA;AACsC,UAAA;AACxB,UAAA;AACf,QAAA;AACA,QAAA;AACA,QAAA;AACD,MAAA;AACD,IAAA;AACD,EAAA;AAEO,EAAA;AACR;AvC+wCiE;AACA;AwCtyCP;AACO,EAAA;AAClD,IAAA;AAE8B,IAAA;AACxB,MAAA;AAC8B,MAAA;AACjD,IAAA;AAE2B,IAAA;AACqB,MAAA;AACb,IAAA;AAC9B,MAAA;AAGD,QAAA;AACH,MAAA;AACD,IAAA;AAEmC,IAAA;AACpC,EAAA;AAEY,EAAA;AACc,EAAA;AACF,EAAA;AACkB,IAAA;AAC1C,EAAA;AAEO,EAAA;AACR;AAEqE;AAC9B,EAAA;AACvC;AAEwE;AAC3B,EAAA;AAC7C;AxC+xCiE;AACA;AyCn0C3B;AACoB,EAAA;AAC1D;AAEuC;AACE,EAAA;AACR,IAAA;AAChC,EAAA;AACD;AAEsC;AACO,EAAA;AAC7C;AAEyC;AACE,EAAA;AAC3C;AzCk0CiE;AACA;A0Ch1C7B;AAC8B,EAAA;AACR,IAAA;AAEjD,IAAA;AACN,MAAA;AACO,QAAA;AACN,QAAA;AACkD,QAAA;AAC1C,QAAA;AAC4B,UAAA;AACa,UAAA;AACjD,QAAA;AAE6B,QAAA;AAKsB,QAAA;AACpD,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAE6D,EAAA;AACF,IAAA;AAGnC,IAAA;AAC2B,IAAA;AAE3C,IAAA;AACN,MAAA;AACO,QAAA;AACkD,QAAA;AACtB,QAAA;AAC1B,QAAA;AAC4B,UAAA;AACa,UAAA;AACjD,QAAA;AAC2C,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAE2F,EAAA;AACnF,IAAA;AACN,MAAA;AACO,QAAA;AACiD,QAAA;AACd,QAAA;AACjC,QAAA;AACmC,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAE4D,EAAA;AACX,IAAA;AAEzC,IAAA;AACN,MAAA;AACO,QAAA;AACiD,QAAA;AACd,QAAA;AACjC,QAAA;AAC4B,UAAA;AACa,UAAA;AACjD,QAAA;AAC2C,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AACD;A1Cq0CiE;AACA;A2Ch5CrC;AACe,EAAA;AACvB,IAAA;AAKhB,IAAA;AAE2D,IAAA;AAC9D,EAAA;AAEkD,EAAA;AACX,IAAA;AACH,MAAA;AACH,MAAA;AAG9B,MAAA;AACa,QAAA;AACO,QAAA;AACO,QAAA;AACO,QAAA;AAChB,MAAA;AAEb,IAAA;AACE,MAAA;AACT,IAAA;AACD,EAAA;AAEuD,EAAA;AACK,IAAA;AACxC,IAAA;AAClB,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACD,IAAA;AAEO,IAAA;AACN,MAAA;AACsD,QAAA;AACA,QAAA;AAClC,UAAA;AACjB,YAAA;AACyC,cAAA;AACzC,YAAA;AAC4C,cAAA;AACvC,YAAA;AACY,cAAA;AAC4B,gBAAA;AACrC,cAAA;AACiC,gBAAA;AACxC,cAAA;AACD,YAAA;AACQ,cAAA;AACT,UAAA;AACA,QAAA;AACF,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AACD;A3Cu4CiE;AACA;A4Cx8CjC;AACU,EAAA;AACjC,IAAA;AACN,MAAA;AACO,QAAA;AACiD,QAAA;AACL,QAAA;AAC1C,QAAA;AAC4B,UAAA;AACY,UAAA;AAChD,QAAA;AACgD,QAAA;AACD,QAAA;AACO,QAAA;AACD,QAAA;AACtD,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAEyD,EAAA;AACA,IAAA;AAGjC,IAAA;AAC2B,IAAA;AACX,IAAA;AACC,IAAA;AAEjC,IAAA;AACN,MAAA;AACO,QAAA;AAC4C,QAAA;AAChB,QAAA;AAC1B,QAAA;AAC4B,UAAA;AACa,UAAA;AACjD,QAAA;AAEG,QAAA;AACkC,UAAA;AACO,UAAA;AAEzC,QAAA;AAC0C,QAAA;AACF,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAEiF,EAAA;AACtB,IAAA;AAExB,IAAA;AACA,IAAA;AACM,IAAA;AAEjC,IAAA;AACN,MAAA;AACO,QAAA;AAC4C,QAAA;AAChB,QAAA;AAC1B,QAAA;AAEL,QAAA;AACkC,UAAA;AACO,UAAA;AAEzC,QAAA;AAC0C,QAAA;AACF,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAEoF,EAAA;AACzB,IAAA;AAExB,IAAA;AACA,IAAA;AAE3B,IAAA;AACN,MAAA;AACO,QAAA;AAC4C,QAAA;AAChB,QAAA;AAC1B,QAAA;AACD,QAAA;AAC4B,UAAA;AACO,UAAA;AAC1C,QAAA;AACU,QAAA;AACiC,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAMC,EAAA;AAE6D,IAAA;AACD,IAAA;AAErD,IAAA;AACN,MAAA;AACO,QAAA;AAC4C,QAAA;AAChB,QAAA;AAC1B,QAAA;AACD,QAAA;AACsC,QAAA;AAC7C,QAAA;AACD,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAE0C,EAAA;AACD,IAAA;AACzC,EAAA;AACD;A5Co7CiE;AACA;A6CnjDhC;AAC2B,EAAA;AAC3B,IAAA;AAC9B,MAAA;AACkD,MAAA;AACnD,IAAA;AAE0C,IAAA;AACT,IAAA;AACoB,MAAA;AACb,MAAA;AACxC,IAAA;AAEoD,IAAA;AAE7C,IAAA;AACN,MAAA;AACO,QAAA;AACH,QAAA;AAC8B,QAAA;AACzB,QAAA;AACU,QAAA;AACmC,UAAA;AACrD,QAAA;AACA,QAAA;AAC0B,QAAA;AACoB,UAAA;AAC9C,QAAA;AACD,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAE0D,EAAA;AACC,IAAA;AAGnC,IAAA;AAC2B,IAAA;AAEjB,IAAA;AAG1B,IAAA;AACN,MAAA;AACO,QAAA;AACuC,QAAA;AAC7C,QAAA;AACQ,QAAA;AAC4B,UAAA;AACa,UAAA;AACjD,QAAA;AACkD,QAAA;AAChB,QAAA;AACS,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAEmF,EAAA;AAC3E,IAAA;AACN,MAAA;AACO,QAAA;AACuC,QAAA;AACQ,QAAA;AACX,QAAA;AAClC,QAAA;AACyC,QAAA;AACN,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAEsF,EAAA;AAC9E,IAAA;AACN,MAAA;AACO,QAAA;AACuC,QAAA;AACZ,QAAA;AACS,QAAA;AAClC,QAAA;AACyC,QAAA;AACN,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAEyD,EAAA;AACD,IAAA;AAEhD,IAAA;AACN,MAAA;AACO,QAAA;AAC2C,QAAA;AACI,QAAA;AACX,QAAA;AAClC,QAAA;AAC4B,UAAA;AACa,UAAA;AACjD,QAAA;AACM,QAAA;AACqC,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAEyC,EAAA;AACO,IAAA;AAChD,EAAA;AACD;A7CuiDiE;AACA;A8CzpDhC;AACU,EAAA;AAClC,IAAA;AACA,MAAA;AACiD,MAAA;AACL,MAAA;AAC1C,MAAA;AACwC,QAAA;AACZ,QAAA;AACpC,MAAA;AACgD,MAAA;AACW,MAAA;AACxB,MAAA;AACI,MAAA;AACZ,MAAA;AACI,MAAA;AAChC,IAAA;AACD,EAAA;AAE0D,EAAA;AACC,IAAA;AAExB,IAAA;AACgB,IAAA;AACV,IAAA;AAEjC,IAAA;AACA,MAAA;AACkD,MAAA;AACtB,MAAA;AAC1B,MAAA;AACyC,QAAA;AACb,QAAA;AACpC,MAAA;AAC6C,MAAA;AACF,MAAA;AAC5C,IAAA;AACD,EAAA;AAEsF,EAAA;AAC9E,IAAA;AACA,MAAA;AACiC,MAAA;AACE,MAAA;AACjC,MAAA;AACE,MAAA;AACiC,MAAA;AAC5C,IAAA;AACD,EAAA;AAE2D,EAAA;AACA,IAAA;AAEV,IAAA;AACE,IAAA;AACV,IAAA;AAEjC,IAAA;AACN,MAAA;AACO,QAAA;AAE0C,QAAA;AAE9C,UAAA;AACE,QAAA;AAC8B,QAAA;AAC1B,QAAA;AAC4B,UAAA;AACa,UAAA;AACjD,QAAA;AAC6C,QAAA;AACF,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AACD;A9CkpDiE;AACA;A+C7tD/B;AAC4B,EAAA;AACxC,IAAA;AACnB,MAAA;AACoD,MAAA;AACrD,IAAA;AAEO,IAAA;AACN,MAAA;AACO,QAAA;AACH,QAAA;AACkD,QAAA;AACF,QAAA;AACd,UAAA;AACrC,QAAA;AAEoB,QAAA;AAGqB,UAAA;AACjC,QAAA;AAEY,QAAA;AAGqB,UAAA;AACjC,QAAA;AAEY,QAAA;AAGqB,UAAA;AACjC,QAAA;AAEY,QAAA;AAG0B,UAAA;AACtC,QAAA;AAEY,QAAA;AAGrB,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAE2D,EAAA;AACA,IAAA;AAGnC,IAAA;AAEhB,IAAA;AACN,MAAA;AACO,QAAA;AACmC,QAAA;AACP,QAAA;AACS,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AAE6D,EAAA;AACrD,IAAA;AACN,MAAA;AACO,QAAA;AACmC,QAAA;AACA,QAAA;AACE,QAAA;AAC5C,MAAA;AACA,MAAA;AACD,IAAA;AACD,EAAA;AACD;A/C0sDiE;AACA;AgDvxD/B;AACmB,EAAA;AACC,IAAA;AACS,IAAA;AAS7C,IAAA;AACE,MAAA;AACE,MAAA;AACE,MAAA;AACL,MAAA;AACI,MAAA;AACD,MAAA;AACM,MAAA;AAC1B,IAAA;AAEmB,IAAA;AACO,MAAA;AACnB,IAAA;AACC,MAAA;AACR,IAAA;AACD,EAAA;AACD;AhDgxDiE;AACA;AC1xDd;AAEtB;AACpB,EAAA;AACA,EAAA;AACA,EAAA;AAAA;AAAA;AAAA;AAAA;AAMa,EAAA;AACW,IAAA;AAChB,IAAA;AACY,IAAA;AACjB,MAAA;AACA,MAAA;AAEP,QAAA;AACkB,QAAA;AACpB,MAAA;AACiB,MAAA;AACjB,IAAA;AAE2C,IAAA;AAC1B,MAAA;AACwC,QAAA;AACtC,QAAA;AACO,UAAA;AACzB,QAAA;AACD,MAAA;AAEO,MAAA;AACP,IAAA;AAE4C,IAAA;AACL,MAAA;AACc,QAAA;AACV,QAAA;AACD,UAAA;AAC5B,UAAA;AACqC,YAAA;AACjD,UAAA;AACD,QAAA;AACD,MAAA;AAEO,MAAA;AACP,IAAA;AACF,EAAA;AAAA;AAAA;AAAA;AAUG,EAAA;AACmD,IAAA;AAExC,IAAA;AACoC,MAAA;AACF,QAAA;AAChC,QAAA;AAEwB,QAAA;AACtC,MAAA;AACD,IAAA;AAE0C,IAAA;AACY,IAAA;AAIhD,IAAA;AACA,MAAA;AACgB,QAAA;AACZ,MAAA;AACA,QAAA;AACR,MAAA;AAEe,IAAA;AAEa,IAAA;AACf,MAAA;AACL,QAAA;AACL,QAAA;AACJ,MAAA;AACD,IAAA;AAEkB,IAAA;AACF,MAAA;AAChB,IAAA;AAEyB,IAAA;AACA,IAAA;AACkB,IAAA;AAEpC,IAAA;AACR,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeE,EAAA;AACiB,IAAA;AACD,MAAA;AACjB,IAAA;AAEqC,IAAA;AACZ,MAAA;AACS,MAAA;AACgB,MAAA;AACZ,MAAA;AACG,MAAA;AACR,MAAA;AACC,MAAA;AACG,MAAA;AACK,MAAA;AACQ,MAAA;AAClD,IAAA;AAE6B,IAAA;AACqB,MAAA;AAClD,IAAA;AAEyC,IAAA;AACrC,MAAA;AACE,MAAA;AACY,MAAA;AACjB,IAAA;AAE6B,IAAA;AAC4B,MAAA;AACzD,MAAA;AACU,QAAA;AACO,UAAA;AACP,UAAA;AACiB,YAAA;AACG,YAAA;AACX,YAAA;AACE,YAAA;AACF,YAAA;AACA,YAAA;AACF,YAAA;AAEZ,cAAA;AACF,YAAA;AACc,YAAA;AACc,cAAA;AACA,cAAA;AACF,cAAA;AAC1B,YAAA;AAC8B,YAAA;AAC/B,UAAA;AACS,UAAA;AACiB,YAAA;AACxB,cAAA;AACM,gBAAA;AACE,gBAAA;AACR,cAAA;AACA,cAAA;AACM,gBAAA;AACE,gBAAA;AACR,cAAA;AACA,cAAA;AACM,gBAAA;AACE,gBAAA;AACR,cAAA;AACD,YAAA;AACe,YAAA;AAChB,UAAA;AACM,UAAA;AACa,YAAA;AACnB,UAAA;AACD,QAAA;AACG,QAAA;AACJ,MAAA;AACA,MAAA;AACe,QAAA;AACd,QAAA;AACD,MAAA;AACD,IAAA;AAEkD,IAAA;AACnD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQoE,EAAA;AAC5D,IAAA;AACsB,MAAA;AACpB,QAAA;AACP,MAAA;AACD,MAAA;AACD,IAAA;AACD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAO4D,EAAA;AACF,IAAA;AACxD,MAAA;AACQ,MAAA;AACR,IAAA;AAE+B,IAAA;AAGjC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOiE,EAAA;AACP,IAAA;AACxD,MAAA;AACQ,MAAA;AACR,IAAA;AAE+B,IAAA;AACpB,MAAA;AACZ,IAAA;AACD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOmE,EAAA;AACT,IAAA;AACxD,MAAA;AACQ,MAAA;AACR,IAAA;AAE+B,IAAA;AACnB,MAAA;AACb,IAAA;AACD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOqE,EAAA;AACX,IAAA;AACxD,MAAA;AACQ,MAAA;AACR,IAAA;AAE+B,IAAA;AAClB,MAAA;AACd,IAAA;AACD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOmE,EAAA;AACT,IAAA;AACxD,MAAA;AACQ,MAAA;AACR,IAAA;AAE+B,IAAA;AACnB,MAAA;AACb,IAAA;AACD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOyE,EAAA;AACf,IAAA;AACxD,MAAA;AACQ,MAAA;AACR,IAAA;AAE+B,IAAA;AAChB,MAAA;AAChB,IAAA;AACD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQyD,EAAA;AACG,IAAA;AACE,IAAA;AAE3B,IAAA;AACY,IAAA;AACvC,IAAA;AACR,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQ2D,EAAA;AACC,IAAA;AACE,IAAA;AAEzB,IAAA;AACW,IAAA;AACxC,IAAA;AACR,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQwC,EAAA;AACoB,IAAA;AACC,IAAA;AACP,IAAA;AAEM,IAAA;AACF,IAAA;AAMrD,IAAA;AAEL,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQ8D,EAAA;AACV,IAAA;AACxC,MAAA;AACV,IAAA;AAEuC,IAAA;AACzC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQuE,EAAA;AACb,IAAA;AAC9C,MAAA;AACV,IAAA;AACwC,IAAA;AAEC,IAAA;AAEc,IAAA;AAC7C,MAAA;AACV,IAAA;AACuD,IAAA;AACvB,IAAA;AAChC,MAAA;AACC,MAAA;AAC6B,MAAA;AAC/B,IAAA;AAEO,IAAA;AACqB,MAAA;AACI,MAAA;AAC9B,IAAA;AAC6B,MAAA;AAC7B,QAAA;AACoD,QAAA;AACpD,MAAA;AACF,IAAA;AACD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQyE,EAAA;AACf,IAAA;AAC9C,MAAA;AACV,IAAA;AACiD,IAAA;AACJ,IAAA;AAEW,IAAA;AAEE,IAAA;AACvB,MAAA;AAClC,QAAA;AACyD,QAAA;AACzD,MAAA;AACF,IAAA;AACD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQ2D,EAAA;AACP,IAAA;AACxC,MAAA;AACV,IAAA;AAEqC,IAAA;AACvC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQoE,EAAA;AACd,IAAA;AACF,IAAA;AACxC,MAAA;AACV,IAAA;AAE2C,IAAA;AAC7C,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQ6E,EAAA;AACvB,IAAA;AACM,IAAA;AAChD,MAAA;AACV,IAAA;AAEa,IAAA;AACb,MAAA;AACA,MAAA;AACA,MAAA;AACD,IAAA;AACwD,IAAA;AACf,IAAA;AACiB,MAAA;AACnB,MAAA;AACW,MAAA;AAClD,IAAA;AAE+C,IAAA;AAChD,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOuD,EAAA;AACH,IAAA;AACxC,MAAA;AACV,IAAA;AAEoD,IAAA;AACC,IAAA;AACjC,IAAA;AACqC,MAAA;AACrB,MAAA;AACc,MAAA;AACnD,IAAA;AAE2C,IAAA;AAC5C,EAAA;AACD;AD2sDiE;AACA;AiDhtElD;AjDktEkD;AACA;AACA","file":"/home/jack/code/ytmusic-api/dist/index.js","sourcesContent":[null,"import axios, { AxiosInstance } from \"axios\"\nimport { Cookie, CookieJar } from \"tough-cookie\"\n\nimport { FE_MUSIC_HOME } from \"./constants\"\nimport AlbumParser from \"./parsers/AlbumParser\"\nimport ArtistParser from \"./parsers/ArtistParser\"\nimport Parser from \"./parsers/Parser\"\nimport PlaylistParser from \"./parsers/PlaylistParser\"\nimport SearchParser from \"./parsers/SearchParser\"\nimport SongParser from \"./parsers/SongParser\"\nimport VideoParser from \"./parsers/VideoParser\"\nimport {\n\tAlbumDetailed,\n\tAlbumFull,\n\tArtistDetailed,\n\tArtistFull,\n\tHomeSection,\n\tPlaylistDetailed,\n\tPlaylistFull,\n\tSearchResult,\n\tSongDetailed,\n\tSongFull,\n\tVideoDetailed,\n\tVideoFull,\n} from \"./types\"\nimport { traverse, traverseList, traverseString } from \"./utils/traverse\"\n\naxios.defaults.headers.common[\"Accept-Encoding\"] = \"gzip\"\n\nexport default class YTMusic {\n\tprivate cookiejar: CookieJar\n\tprivate config?: Record<string, string>\n\tprivate client: AxiosInstance\n\n\t/**\n\t * Creates an instance of YTMusic\n\t * Make sure to call initialize()\n\t */\n\tpublic constructor() {\n\t\tthis.cookiejar = new CookieJar()\n\t\tthis.config = {}\n\t\tthis.client = axios.create({\n\t\t\tbaseURL: \"https://music.youtube.com/\",\n\t\t\theaders: {\n\t\t\t\t\"User-Agent\":\n\t\t\t\t\t\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\",\n\t\t\t\t\"Accept-Language\": \"en-US,en;q=0.5\",\n\t\t\t},\n\t\t\twithCredentials: true,\n\t\t})\n\n\t\tthis.client.interceptors.request.use(req => {\n\t\t\tif (req.baseURL) {\n\t\t\t\tconst cookieString = this.cookiejar.getCookieStringSync(req.baseURL)\n\t\t\t\tif (cookieString) {\n\t\t\t\t\treq.headers[\"cookie\"] = cookieString\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn req\n\t\t})\n\n\t\tthis.client.interceptors.response.use(res => {\n\t\t\tif (res.headers && res.config.baseURL) {\n\t\t\t\tconst cookieStrings = res.headers[\"set-cookie\"] || []\n\t\t\t\tfor (const cookieString of cookieStrings) {\n\t\t\t\t\tconst cookie = Cookie.parse(cookieString)\n\t\t\t\t\tif (cookie) {\n\t\t\t\t\t\tthis.cookiejar.setCookieSync(cookie, res.config.baseURL)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res\n\t\t})\n\t}\n\n\t/**\n\t * Initializes the API\n\t */\n\tpublic async initialize(options?: {\n\t\tcookies?: string\n\t\tGL?: string\n\t\tHL?: string\n\t\taccessToken?: string\n\t}) {\n\t\tconst { cookies, GL, HL, accessToken } = options ?? {}\n\n\t\tif (cookies) {\n\t\t\tfor (const cookieString of cookies.split(\"; \")) {\n\t\t\t\tconst cookie = Cookie.parse(`${cookieString}`)\n\t\t\t\tif (!cookie) return\n\n\t\t\t\tthis.cookiejar.setCookieSync(cookie, \"https://www.youtube.com/\")\n\t\t\t}\n\t\t}\n\n\t\tconst html = (await this.client.get(\"/\")).data as string\n\t\tconst setConfigs = html.match(/ytcfg\\.set\\(.*\\)/) || []\n\n\t\tconst configs = setConfigs\n\t\t\t.map(c => c.slice(10, -1))\n\t\t\t.map(s => {\n\t\t\t\ttry {\n\t\t\t\t\treturn JSON.parse(s)\n\t\t\t\t} catch {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t})\n\t\t\t.filter(j => !!j)\n\n\t\tfor (const config of configs) {\n\t\t\tthis.config = {\n\t\t\t\t...this.config,\n\t\t\t\t...config,\n\t\t\t}\n\t\t}\n\n\t\tif (!this.config) {\n\t\t\tthis.config = {}\n\t\t}\n\n\t\tif (GL) this.config.GL = GL\n\t\tif (HL) this.config.HL = HL\n\t\tif (accessToken) this.config.accessToken = accessToken\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Constructs a basic YouTube Music API request with all essential headers\n\t * and body parameters needed to make the API work\n\t *\n\t * @param endpoint Endpoint for the request\n\t * @param body Body\n\t * @param query Search params\n\t * @returns Raw response from YouTube Music API which needs to be parsed\n\t */\n\tprivate async constructRequest(\n\t\tendpoint: string,\n\t\tbody: Record<string, any> = {},\n\t\tquery: Record<string, string> = {},\n\t) {\n\t\tif (!this.config) {\n\t\t\tthrow new Error(\"API not initialized. Make sure to call the initialize() method first\")\n\t\t}\n\n\t\tconst headers: Record<string, any> = {\n\t\t\t...this.client.defaults.headers,\n\t\t\t\"x-origin\": this.client.defaults.baseURL,\n\t\t\t\"X-Goog-Visitor-Id\": this.config.VISITOR_DATA || \"\",\n\t\t\t\"X-YouTube-Client-Name\": this.config.INNERTUBE_CONTEXT_CLIENT_NAME,\n\t\t\t\"X-YouTube-Client-Version\": this.config.INNERTUBE_CLIENT_VERSION,\n\t\t\t\"X-YouTube-Device\": this.config.DEVICE,\n\t\t\t\"X-YouTube-Page-CL\": this.config.PAGE_CL,\n\t\t\t\"X-YouTube-Page-Label\": this.config.PAGE_BUILD_LABEL,\n\t\t\t\"X-YouTube-Utc-Offset\": String(-new Date().getTimezoneOffset()),\n\t\t\t\"X-YouTube-Time-Zone\": new Intl.DateTimeFormat().resolvedOptions().timeZone,\n\t\t}\n\n\t\tif (this.config.accessToken) {\n\t\t\theaders['Authorization'] = `Bearer ${this.config.accessToken}`\n\t\t}\n\n\t\tconst searchParams = new URLSearchParams({\n\t\t\t...query,\n\t\t\talt: \"json\",\n\t\t\tkey: this.config.INNERTUBE_API_KEY!,\n\t\t})\n\n\t\tconst res = await this.client.post(\n\t\t\t`youtubei/${this.config.INNERTUBE_API_VERSION}/${endpoint}?${searchParams.toString()}`,\n\t\t\t{\n\t\t\t\tcontext: {\n\t\t\t\t\tcapabilities: {},\n\t\t\t\t\tclient: {\n\t\t\t\t\t\tclientName: this.config.INNERTUBE_CLIENT_NAME,\n\t\t\t\t\t\tclientVersion: this.config.INNERTUBE_CLIENT_VERSION,\n\t\t\t\t\t\texperimentIds: [],\n\t\t\t\t\t\texperimentsToken: \"\",\n\t\t\t\t\t\tgl: this.config.GL,\n\t\t\t\t\t\thl: this.config.HL,\n\t\t\t\t\t\tlocationInfo: {\n\t\t\t\t\t\t\tlocationPermissionAuthorizationStatus:\n\t\t\t\t\t\t\t\t\"LOCATION_PERMISSION_AUTHORIZATION_STATUS_UNSUPPORTED\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmusicAppInfo: {\n\t\t\t\t\t\t\tmusicActivityMasterSwitch: \"MUSIC_ACTIVITY_MASTER_SWITCH_INDETERMINATE\",\n\t\t\t\t\t\t\tmusicLocationMasterSwitch: \"MUSIC_LOCATION_MASTER_SWITCH_INDETERMINATE\",\n\t\t\t\t\t\t\tpwaInstallabilityStatus: \"PWA_INSTALLABILITY_STATUS_UNKNOWN\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tutcOffsetMinutes: -new Date().getTimezoneOffset(),\n\t\t\t\t\t},\n\t\t\t\t\trequest: {\n\t\t\t\t\t\tinternalExperimentFlags: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tkey: \"force_music_enable_outertube_tastebuilder_browse\",\n\t\t\t\t\t\t\t\tvalue: \"true\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tkey: \"force_music_enable_outertube_playlist_detail_browse\",\n\t\t\t\t\t\t\t\tvalue: \"true\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tkey: \"force_music_enable_outertube_search_suggestions\",\n\t\t\t\t\t\t\t\tvalue: \"true\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\tsessionIndex: {},\n\t\t\t\t\t},\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tenableSafetyMode: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t...body,\n\t\t\t},\n\t\t\t{\n\t\t\t\tresponseType: \"json\",\n\t\t\t\theaders,\n\t\t\t},\n\t\t)\n\n\t\treturn \"responseContext\" in res.data ? res.data : res\n\t}\n\n\t/**\n\t * Get a list of search suggestiong based on the query\n\t *\n\t * @param query Query string\n\t * @returns Search suggestions\n\t */\n\tpublic async getSearchSuggestions(query: string): Promise<string[]> {\n\t\treturn traverseList(\n\t\t\tawait this.constructRequest(\"music/get_search_suggestions\", {\n\t\t\t\tinput: query,\n\t\t\t}),\n\t\t\t\"query\",\n\t\t)\n\t}\n\n\t/**\n\t * Searches YouTube Music API for results\n\t *\n\t * @param query Query string\n\t */\n\tpublic async search(query: string): Promise<SearchResult[]> {\n\t\tconst searchData = await this.constructRequest(\"search\", {\n\t\t\tquery,\n\t\t\tparams: null,\n\t\t})\n\n\t\treturn traverseList(searchData, \"musicResponsiveListItemRenderer\")\n\t\t\t.map(SearchParser.parse)\n\t\t\t.filter(Boolean) as SearchResult[]\n\t}\n\n\t/**\n\t * Searches YouTube Music API for songs\n\t *\n\t * @param query Query string\n\t */\n\tpublic async searchSongs(query: string): Promise<SongDetailed[]> {\n\t\tconst searchData = await this.constructRequest(\"search\", {\n\t\t\tquery,\n\t\t\tparams: \"Eg-KAQwIARAAGAAgACgAMABqChAEEAMQCRAFEAo%3D\",\n\t\t})\n\n\t\treturn traverseList(searchData, \"musicResponsiveListItemRenderer\").map(\n\t\t\tSongParser.parseSearchResult,\n\t\t)\n\t}\n\n\t/**\n\t * Searches YouTube Music API for videos\n\t *\n\t * @param query Query string\n\t */\n\tpublic async searchVideos(query: string): Promise<VideoDetailed[]> {\n\t\tconst searchData = await this.constructRequest(\"search\", {\n\t\t\tquery,\n\t\t\tparams: \"Eg-KAQwIABABGAAgACgAMABqChAEEAMQCRAFEAo%3D\",\n\t\t})\n\n\t\treturn traverseList(searchData, \"musicResponsiveListItemRenderer\").map(\n\t\t\tVideoParser.parseSearchResult,\n\t\t)\n\t}\n\n\t/**\n\t * Searches YouTube Music API for artists\n\t *\n\t * @param query Query string\n\t */\n\tpublic async searchArtists(query: string): Promise<ArtistDetailed[]> {\n\t\tconst searchData = await this.constructRequest(\"search\", {\n\t\t\tquery,\n\t\t\tparams: \"Eg-KAQwIABAAGAAgASgAMABqChAEEAMQCRAFEAo%3D\",\n\t\t})\n\n\t\treturn traverseList(searchData, \"musicResponsiveListItemRenderer\").map(\n\t\t\tArtistParser.parseSearchResult,\n\t\t)\n\t}\n\n\t/**\n\t * Searches YouTube Music API for albums\n\t *\n\t * @param query Query string\n\t */\n\tpublic async searchAlbums(query: string): Promise<AlbumDetailed[]> {\n\t\tconst searchData = await this.constructRequest(\"search\", {\n\t\t\tquery,\n\t\t\tparams: \"Eg-KAQwIABAAGAEgACgAMABqChAEEAMQCRAFEAo%3D\",\n\t\t})\n\n\t\treturn traverseList(searchData, \"musicResponsiveListItemRenderer\").map(\n\t\t\tAlbumParser.parseSearchResult,\n\t\t)\n\t}\n\n\t/**\n\t * Searches YouTube Music API for playlists\n\t *\n\t * @param query Query string\n\t */\n\tpublic async searchPlaylists(query: string): Promise<PlaylistDetailed[]> {\n\t\tconst searchData = await this.constructRequest(\"search\", {\n\t\t\tquery,\n\t\t\tparams: \"Eg-KAQwIABAAGAAgACgBMABqChAEEAMQCRAFEAo%3D\",\n\t\t})\n\n\t\treturn traverseList(searchData, \"musicResponsiveListItemRenderer\").map(\n\t\t\tPlaylistParser.parseSearchResult,\n\t\t)\n\t}\n\n\t/**\n\t * Get all possible information of a Song\n\t *\n\t * @param videoId Video ID\n\t * @returns Song Data\n\t */\n\tpublic async getSong(videoId: string): Promise<SongFull> {\n\t\tif (!videoId.match(/^[a-zA-Z0-9-_]{11}$/)) throw new Error(\"Invalid videoId\")\n\t\tconst data = await this.constructRequest(\"player\", { videoId })\n\n\t\tconst song = SongParser.parse(data)\n\t\tif (song.videoId !== videoId) throw new Error(\"Invalid videoId\")\n\t\treturn song\n\t}\n\n\t/**\n\t * Get all possible information of a Video\n\t *\n\t * @param videoId Video ID\n\t * @returns Video Data\n\t */\n\tpublic async getVideo(videoId: string): Promise<VideoFull> {\n\t\tif (!videoId.match(/^[a-zA-Z0-9-_]{11}$/)) throw new Error(\"Invalid videoId\")\n\t\tconst data = await this.constructRequest(\"player\", { videoId })\n\n\t\tconst video = VideoParser.parse(data)\n\t\tif (video.videoId !== videoId) throw new Error(\"Invalid videoId\")\n\t\treturn video\n\t}\n\n\t/**\n\t * Get lyrics of a specific Song\n\t *\n\t * @param videoId Video ID\n\t * @returns Lyrics\n\t */\n\tpublic async getLyrics(videoId: string) {\n\t\tif (!videoId.match(/^[a-zA-Z0-9-_]{11}$/)) throw new Error(\"Invalid videoId\")\n\t\tconst data = await this.constructRequest(\"next\", { videoId })\n\t\tconst browseId = traverse(traverseList(data, \"tabs\", \"tabRenderer\")[1], \"browseId\")\n\n\t\tconst lyricsData = await this.constructRequest(\"browse\", { browseId })\n\t\tconst lyrics = traverseString(lyricsData, \"description\", \"runs\", \"text\")\n\n\t\treturn lyrics\n\t\t\t? lyrics\n\t\t\t\t\t.replaceAll(\"\\r\", \"\")\n\t\t\t\t\t.split(\"\\n\")\n\t\t\t\t\t.filter(v => !!v)\n\t\t\t: null\n\t}\n\n\t/**\n\t * Get all possible information of an Artist\n\t *\n\t * @param artistId Artist ID\n\t * @returns Artist Data\n\t */\n\tpublic async getArtist(artistId: string): Promise<ArtistFull> {\n\t\tconst data = await this.constructRequest(\"browse\", {\n\t\t\tbrowseId: artistId,\n\t\t})\n\n\t\treturn ArtistParser.parse(data, artistId)\n\t}\n\n\t/**\n\t * Get all of Artist's Songs\n\t *\n\t * @param artistId Artist ID\n\t * @returns Artist's Songs\n\t */\n\tpublic async getArtistSongs(artistId: string): Promise<SongDetailed[]> {\n\t\tconst artistData = await this.constructRequest(\"browse\", {\n\t\t\tbrowseId: artistId,\n\t\t})\n\t\tconst browseToken = traverse(artistData, \"musicShelfRenderer\", \"title\", \"browseId\")\n\n\t\tif (browseToken instanceof Array) return []\n\n\t\tconst songsData = await this.constructRequest(\"browse\", {\n\t\t\tbrowseId: browseToken,\n\t\t})\n\t\tconst continueToken = traverse(songsData, \"continuation\")\n\t\tconst moreSongsData = await this.constructRequest(\n\t\t\t\"browse\",\n\t\t\t{},\n\t\t\t{ continuation: continueToken },\n\t\t)\n\n\t\treturn [\n\t\t\t...traverseList(songsData, \"musicResponsiveListItemRenderer\"),\n\t\t\t...traverseList(moreSongsData, \"musicResponsiveListItemRenderer\"),\n\t\t].map(s =>\n\t\t\tSongParser.parseArtistSong(s, {\n\t\t\t\tartistId,\n\t\t\t\tname: traverseString(artistData, \"header\", \"title\", \"text\"),\n\t\t\t}),\n\t\t)\n\t}\n\n\t/**\n\t * Get all of Artist's Albums\n\t *\n\t * @param artistId Artist ID\n\t * @returns Artist's Albums\n\t */\n\tpublic async getArtistAlbums(artistId: string): Promise<AlbumDetailed[]> {\n\t\tconst artistData = await this.constructRequest(\"browse\", {\n\t\t\tbrowseId: artistId,\n\t\t})\n\t\tconst artistAlbumsData = traverseList(artistData, \"musicCarouselShelfRenderer\")[0]\n\t\tconst browseBody = traverse(artistAlbumsData, \"moreContentButton\", \"browseEndpoint\")\n\n\t\tconst albumsData = await this.constructRequest(\"browse\", browseBody)\n\n\t\treturn traverseList(albumsData, \"musicTwoRowItemRenderer\").map(item =>\n\t\t\tAlbumParser.parseArtistAlbum(item, {\n\t\t\t\tartistId,\n\t\t\t\tname: traverseString(albumsData, \"header\", \"runs\", \"text\"),\n\t\t\t}),\n\t\t)\n\t}\n\n\t/**\n\t * Get all possible information of an Album\n\t *\n\t * @param albumId Album ID\n\t * @returns Album Data\n\t */\n\tpublic async getAlbum(albumId: string): Promise<AlbumFull> {\n\t\tconst data = await this.constructRequest(\"browse\", {\n\t\t\tbrowseId: albumId,\n\t\t})\n\n\t\treturn AlbumParser.parse(data, albumId)\n\t}\n\n\t/**\n\t * Get all possible information of a Playlist except the tracks\n\t *\n\t * @param playlistId Playlist ID\n\t * @returns Playlist Data\n\t */\n\tpublic async getPlaylist(playlistId: string): Promise<PlaylistFull> {\n\t\tif (playlistId.startsWith(\"PL\")) playlistId = \"VL\" + playlistId\n\t\tconst data = await this.constructRequest(\"browse\", {\n\t\t\tbrowseId: playlistId,\n\t\t})\n\n\t\treturn PlaylistParser.parse(data, playlistId)\n\t}\n\n\t/**\n\t * Get all videos in a Playlist\n\t *\n\t * @param playlistId Playlist ID\n\t * @returns Playlist's Videos\n\t */\n\tpublic async getPlaylistVideos(playlistId: string): Promise<VideoDetailed[]> {\n\t\tif (playlistId.startsWith(\"PL\")) playlistId = \"VL\" + playlistId\n\t\tconst playlistData = await this.constructRequest(\"browse\", {\n\t\t\tbrowseId: playlistId,\n\t\t})\n\n\t\tconst songs = traverseList(\n\t\t\tplaylistData,\n\t\t\t\"musicPlaylistShelfRenderer\",\n\t\t\t\"musicResponsiveListItemRenderer\",\n\t\t)\n\t\tlet continuation = traverse(playlistData, \"continuation\")\n\t\twhile (!(continuation instanceof Array)) {\n\t\t\tconst songsData = await this.constructRequest(\"browse\", {}, { continuation })\n\t\t\tsongs.push(...traverseList(songsData, \"musicResponsiveListItemRenderer\"))\n\t\t\tcontinuation = traverse(songsData, \"continuation\")\n\t\t}\n\n\t\treturn songs.map(VideoParser.parsePlaylistVideo)\n\t}\n\n\t/**\n\t * Get sections for the home page.\n\t *\n\t * @returns Mixed HomeSection\n\t */\n\tpublic async getHomeSections(): Promise<HomeSection[]> {\n\t\tconst data = await this.constructRequest(\"browse\", {\n\t\t\tbrowseId: FE_MUSIC_HOME,\n\t\t})\n\n\t\tconst sections = traverseList(\"sectionListRenderer\", \"contents\")\n\t\tlet continuation = traverseString(data, \"continuation\")\n\t\twhile (continuation) {\n\t\t\tconst data = await this.constructRequest(\"browse\", {}, { continuation })\n\t\t\tsections.push(...traverseList(data, \"sectionListContinuation\", \"contents\"))\n\t\t\tcontinuation = traverseString(data, \"continuation\")\n\t\t}\n\n\t\treturn sections.map(Parser.parseHomeSection)\n\t}\n}\n","export enum PageType {\n\tMUSIC_PAGE_TYPE_ALBUM = \"MUSIC_PAGE_TYPE_ALBUM\",\n\tMUSIC_PAGE_TYPE_PLAYLIST = \"MUSIC_PAGE_TYPE_PLAYLIST\",\n\tMUSIC_VIDEO_TYPE_OMV = \"MUSIC_VIDEO_TYPE_OMV\",\n}\n\nexport const FE_MUSIC_HOME = \"FEmusic_home\"\n","import { z } from \"zod\"\n\nexport type ThumbnailFull = z.infer<typeof ThumbnailFull>\nexport const ThumbnailFull = z\n\t.object({\n\t\turl: z.string(),\n\t\twidth: z.number(),\n\t\theight: z.number(),\n\t})\n\t.strict()\n\nexport type ArtistBasic = z.infer<typeof ArtistBasic>\nexport const ArtistBasic = z\n\t.object({\n\t\tartistId: z.nullable(z.string()),\n\t\tname: z.string(),\n\t})\n\t.strict()\n\nexport type AlbumBasic = z.infer<typeof AlbumBasic>\nexport const AlbumBasic = z\n\t.object({\n\t\talbumId: z.string(),\n\t\tname: z.string(),\n\t})\n\t.strict()\n\nexport type SongDetailed = z.infer<typeof SongDetailed>\nexport const SongDetailed = z\n\t.object({\n\t\ttype: z.literal(\"SONG\"),\n\t\tvideoId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\talbum: z.nullable(AlbumBasic),\n\t\tduration: z.nullable(z.number()),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type VideoDetailed = z.infer<typeof VideoDetailed>\nexport const VideoDetailed = z\n\t.object({\n\t\ttype: z.literal(\"VIDEO\"),\n\t\tvideoId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tduration: z.nullable(z.number()),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type ArtistDetailed = z.infer<typeof ArtistDetailed>\nexport const ArtistDetailed = z\n\t.object({\n\t\tartistId: z.string(),\n\t\tname: z.string(),\n\t\ttype: z.literal(\"ARTIST\"),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type AlbumDetailed = z.infer<typeof AlbumDetailed>\nexport const AlbumDetailed = z\n\t.object({\n\t\ttype: z.literal(\"ALBUM\"),\n\t\talbumId: z.string(),\n\t\tplaylistId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tyear: z.nullable(z.number()),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type PlaylistDetailed = z.infer<typeof PlaylistDetailed>\nexport const PlaylistDetailed = z\n\t.object({\n\t\ttype: z.literal(\"PLAYLIST\"),\n\t\tplaylistId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type SongFull = z.infer<typeof SongFull>\nexport const SongFull = z\n\t.object({\n\t\ttype: z.literal(\"SONG\"),\n\t\tvideoId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tduration: z.number(),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t\tformats: z.array(z.any()),\n\t\tadaptiveFormats: z.array(z.any()),\n\t})\n\t.strict()\n\nexport type VideoFull = z.infer<typeof VideoFull>\nexport const VideoFull = z\n\t.object({\n\t\ttype: z.literal(\"VIDEO\"),\n\t\tvideoId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tduration: z.number(),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t\tunlisted: z.boolean(),\n\t\tfamilySafe: z.boolean(),\n\t\tpaid: z.boolean(),\n\t\ttags: z.array(z.string()),\n\t})\n\t.strict()\n\nexport type ArtistFull = z.infer<typeof ArtistFull>\nexport const ArtistFull = z\n\t.object({\n\t\tartistId: z.string(),\n\t\tname: z.string(),\n\t\ttype: z.literal(\"ARTIST\"),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t\ttopSongs: z.array(SongDetailed),\n\t\ttopAlbums: z.array(AlbumDetailed),\n\t\ttopSingles: z.array(AlbumDetailed),\n\t\ttopVideos: z.array(VideoDetailed),\n\t\tfeaturedOn: z.array(PlaylistDetailed),\n\t\tsimilarArtists: z.array(ArtistDetailed),\n\t})\n\t.strict()\n\nexport type AlbumFull = z.infer<typeof AlbumFull>\nexport const AlbumFull = z\n\t.object({\n\t\ttype: z.literal(\"ALBUM\"),\n\t\talbumId: z.string(),\n\t\tplaylistId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tyear: z.nullable(z.number()),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t\tsongs: z.array(SongDetailed),\n\t})\n\t.strict()\n\nexport type PlaylistFull = z.infer<typeof PlaylistFull>\nexport const PlaylistFull = z\n\t.object({\n\t\ttype: z.literal(\"PLAYLIST\"),\n\t\tplaylistId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tvideoCount: z.number(),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type SearchResult = z.infer<typeof SearchResult>\nexport const SearchResult = z.discriminatedUnion(\"type\", [\n\tSongDetailed,\n\tVideoDetailed,\n\tAlbumDetailed,\n\tArtistDetailed,\n\tPlaylistDetailed,\n])\n\nexport type HomeSection = z.infer<typeof HomeSection>\nexport const HomeSection = z\n\t.object({\n\t\ttitle: z.string(),\n\t\tcontents: z.array(z.union([AlbumDetailed, PlaylistDetailed, SongDetailed])),\n\t})\n\t.strict()\n","export const ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nexport const defaultOptions = {\n    name: undefined,\n    $refStrategy: \"root\",\n    basePath: [\"#\"],\n    effectStrategy: \"input\",\n    pipeStrategy: \"all\",\n    dateStrategy: \"format:date-time\",\n    mapStrategy: \"entries\",\n    removeAdditionalStrategy: \"passthrough\",\n    definitionPath: \"definitions\",\n    target: \"jsonSchema7\",\n    strictUnions: false,\n    definitions: {},\n    errorMessages: false,\n    markdownDescription: false,\n    patternStrategy: \"escape\",\n    applyRegexFlags: false,\n    emailStrategy: \"format:email\",\n    base64Strategy: \"contentEncoding:base64\",\n    nameStrategy: \"ref\"\n};\nexport const getDefaultOptions = (options) => (typeof options === \"string\"\n    ? {\n        ...defaultOptions,\n        name: options,\n    }\n    : {\n        ...defaultOptions,\n        ...options,\n    });\n","import { getDefaultOptions } from \"./Options.js\";\nexport const getRefs = (options) => {\n    const _options = getDefaultOptions(options);\n    const currentPath = _options.name !== undefined\n        ? [..._options.basePath, _options.definitionPath, _options.name]\n        : _options.basePath;\n    return {\n        ..._options,\n        currentPath: currentPath,\n        propertyPath: undefined,\n        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n            def._def,\n            {\n                def: def._def,\n                path: [..._options.basePath, _options.definitionPath, name],\n                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                jsonSchema: undefined,\n            },\n        ])),\n    };\n};\n","export function addErrorMessage(res, key, errorMessage, refs) {\n    if (!refs?.errorMessages)\n        return;\n    if (errorMessage) {\n        res.errorMessage = {\n            ...res.errorMessage,\n            [key]: errorMessage,\n        };\n    }\n}\nexport function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n    res[key] = value;\n    addErrorMessage(res, key, errorMessage, refs);\n}\n","import { ZodFirstPartyTypeKind } from \"zod\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef, } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef, } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef, } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef, } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nimport { ignoreOverride } from \"./Options.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchema = selectParser(def, def.typeName, refs);\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return {};\n            }\n            return refs.$refStrategy === \"seen\" ? {} : undefined;\n        }\n    }\n};\nconst getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\nconst selectParser = (def, typeName, refs) => {\n    switch (typeName) {\n        case ZodFirstPartyTypeKind.ZodString:\n            return parseStringDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNumber:\n            return parseNumberDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodObject:\n            return parseObjectDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBigInt:\n            return parseBigintDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBoolean:\n            return parseBooleanDef();\n        case ZodFirstPartyTypeKind.ZodDate:\n            return parseDateDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUndefined:\n            return parseUndefinedDef();\n        case ZodFirstPartyTypeKind.ZodNull:\n            return parseNullDef(refs);\n        case ZodFirstPartyTypeKind.ZodArray:\n            return parseArrayDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUnion:\n        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n            return parseUnionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodIntersection:\n            return parseIntersectionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodTuple:\n            return parseTupleDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodRecord:\n            return parseRecordDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLiteral:\n            return parseLiteralDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodEnum:\n            return parseEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNativeEnum:\n            return parseNativeEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNullable:\n            return parseNullableDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodOptional:\n            return parseOptionalDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodMap:\n            return parseMapDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodSet:\n            return parseSetDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLazy:\n            return parseDef(def.getter()._def, refs);\n        case ZodFirstPartyTypeKind.ZodPromise:\n            return parsePromiseDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNaN:\n        case ZodFirstPartyTypeKind.ZodNever:\n            return parseNeverDef();\n        case ZodFirstPartyTypeKind.ZodEffects:\n            return parseEffectsDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodAny:\n            return parseAnyDef();\n        case ZodFirstPartyTypeKind.ZodUnknown:\n            return parseUnknownDef();\n        case ZodFirstPartyTypeKind.ZodDefault:\n            return parseDefaultDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBranded:\n            return parseBrandedDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodReadonly:\n            return parseReadonlyDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodCatch:\n            return parseCatchDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodPipeline:\n            return parsePipelineDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodFunction:\n        case ZodFirstPartyTypeKind.ZodVoid:\n        case ZodFirstPartyTypeKind.ZodSymbol:\n            return undefined;\n        default:\n            return ((_) => undefined)(typeName);\n    }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n","export function parseAnyDef() {\n    return {};\n}\n","import { ZodFirstPartyTypeKind } from \"zod\";\nimport { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseArrayDef(def, refs) {\n    const res = {\n        type: \"array\",\n    };\n    if (def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n        res.items = parseDef(def.type._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\"],\n        });\n    }\n    if (def.minLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n    }\n    if (def.maxLength) {\n        setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n    }\n    if (def.exactLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n        setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n    }\n    return res;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseBigintDef(def, refs) {\n    const res = {\n        type: \"integer\",\n        format: \"int64\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","export function parseBooleanDef() {\n    return {\n        type: \"boolean\",\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseBrandedDef(_def, refs) {\n    return parseDef(_def.type._def, refs);\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseCatchDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseDateDef(def, refs, overrideDateStrategy) {\n    const strategy = overrideDateStrategy ?? refs.dateStrategy;\n    if (Array.isArray(strategy)) {\n        return {\n            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n        };\n    }\n    switch (strategy) {\n        case \"string\":\n        case \"format:date-time\":\n            return {\n                type: \"string\",\n                format: \"date-time\",\n            };\n        case \"format:date\":\n            return {\n                type: \"string\",\n                format: \"date\",\n            };\n        case \"integer\":\n            return integerDateParser(def, refs);\n    }\n}\nconst integerDateParser = (def, refs) => {\n    const res = {\n        type: \"integer\",\n        format: \"unix-time\",\n    };\n    if (refs.target === \"openApi3\") {\n        return res;\n    }\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                setResponseValueAndErrors(res, \"minimum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n            case \"max\":\n                setResponseValueAndErrors(res, \"maximum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n        }\n    }\n    return res;\n};\n","import { parseDef } from \"../parseDef.js\";\nexport function parseDefaultDef(_def, refs) {\n    return {\n        ...parseDef(_def.innerType._def, refs),\n        default: _def.defaultValue(),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseEffectsDef(_def, refs) {\n    return refs.effectStrategy === \"input\"\n        ? parseDef(_def.schema._def, refs)\n        : {};\n}\n","export function parseEnumDef(def) {\n    return {\n        type: \"string\",\n        enum: def.values,\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n","export function parseLiteralDef(def, refs) {\n    const parsedType = typeof def.value;\n    if (parsedType !== \"bigint\" &&\n        parsedType !== \"number\" &&\n        parsedType !== \"boolean\" &&\n        parsedType !== \"string\") {\n        return {\n            type: Array.isArray(def.value) ? \"array\" : \"object\",\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        return {\n            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n            enum: [def.value],\n        };\n    }\n    return {\n        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n        const: def.value,\n    };\n}\n","import { ZodFirstPartyTypeKind, } from \"zod\";\nimport { parseDef } from \"../parseDef.js\";\nimport { parseStringDef } from \"./string.js\";\nexport function parseRecordDef(def, refs) {\n    if (refs.target === \"openApi3\" &&\n        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            type: \"object\",\n            required: def.keyType._def.values,\n            properties: def.keyType._def.values.reduce((acc, key) => ({\n                ...acc,\n                [key]: parseDef(def.valueType._def, {\n                    ...refs,\n                    currentPath: [...refs.currentPath, \"properties\", key],\n                }) ?? {},\n            }), {}),\n            additionalProperties: false,\n        };\n    }\n    const schema = {\n        type: \"object\",\n        additionalProperties: parseDef(def.valueType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        }) ?? {},\n    };\n    if (refs.target === \"openApi3\") {\n        return schema;\n    }\n    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.checks?.length) {\n        const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce((acc, [key, value]) => (key === \"type\" ? acc : { ...acc, [key]: value }), {});\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            ...schema,\n            propertyNames: {\n                enum: def.keyType._def.values,\n            },\n        };\n    }\n    return schema;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    function processPattern(value) {\n        return refs.patternStrategy === \"escape\"\n            ? escapeNonAlphaNumeric(value)\n            : value;\n    }\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(processPattern(check.value)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji, check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nconst escapeNonAlphaNumeric = (value) => Array.from(value)\n    .map((c) => (/[a-zA-Z0-9]/.test(c) ? c : `\\\\${c}`))\n    .join(\"\");\nconst addFormat = (schema, value, message, refs) => {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n};\nconst addPattern = (schema, regex, message, refs) => {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: processRegExp(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", processRegExp(regex, refs), message, refs);\n    }\n};\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nconst processRegExp = (regexOrFunction, refs) => {\n    const regex = typeof regexOrFunction === \"function\" ? regexOrFunction() : regexOrFunction;\n    if (!refs.applyRegexFlags || !regex.flags)\n        return regex.source;\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        const regexTest = new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n};\n","import { parseDef } from \"../parseDef.js\";\nimport { parseRecordDef } from \"./record.js\";\nexport function parseMapDef(def, refs) {\n    if (refs.mapStrategy === \"record\") {\n        return parseRecordDef(def, refs);\n    }\n    const keys = parseDef(def.keyType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n    }) || {};\n    const values = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n    }) || {};\n    return {\n        type: \"array\",\n        maxItems: 125,\n        items: {\n            type: \"array\",\n            items: [keys, values],\n            minItems: 2,\n            maxItems: 2,\n        },\n    };\n}\n","export function parseNativeEnumDef(def) {\n    const object = def.values;\n    const actualKeys = Object.keys(def.values).filter((key) => {\n        return typeof object[object[key]] !== \"number\";\n    });\n    const actualValues = actualKeys.map((key) => object[key]);\n    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n    return {\n        type: parsedTypes.length === 1\n            ? parsedTypes[0] === \"string\"\n                ? \"string\"\n                : \"number\"\n            : [\"string\", \"number\"],\n        enum: actualValues,\n    };\n}\n","export function parseNeverDef() {\n    return {\n        not: {},\n    };\n}\n","export function parseNullDef(refs) {\n    return refs.target === \"openApi3\"\n        ? {\n            enum: [\"null\"],\n            nullable: true,\n        }\n        : {\n            type: \"null\",\n        };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n","import { parseDef } from \"../parseDef.js\";\nimport { primitiveMappings } from \"./union.js\";\nexport function parseNullableDef(def, refs) {\n    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n        if (refs.target === \"openApi3\") {\n            return {\n                type: primitiveMappings[def.innerType._def.typeName],\n                nullable: true,\n            };\n        }\n        return {\n            type: [\n                primitiveMappings[def.innerType._def.typeName],\n                \"null\",\n            ],\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        const base = parseDef(def.innerType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath],\n        });\n        if (base && '$ref' in base)\n            return { allOf: [base], nullable: true };\n        return base && { ...base, nullable: true };\n    }\n    const base = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n    });\n    return base && { anyOf: [base, { type: \"null\" }] };\n}\n","import { addErrorMessage, setResponseValueAndErrors, } from \"../errorMessages.js\";\nexport function parseNumberDef(def, refs) {\n    const res = {\n        type: \"number\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"int\":\n                res.type = \"integer\";\n                addErrorMessage(res, \"type\", check.message, refs);\n                break;\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","import { parseDef } from \"../parseDef.js\";\nfunction decideAdditionalProperties(def, refs) {\n    if (refs.removeAdditionalStrategy === \"strict\") {\n        return def.catchall._def.typeName === \"ZodNever\"\n            ? def.unknownKeys !== \"strict\"\n            : parseDef(def.catchall._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalProperties\"],\n            }) ?? true;\n    }\n    else {\n        return def.catchall._def.typeName === \"ZodNever\"\n            ? def.unknownKeys === \"passthrough\"\n            : parseDef(def.catchall._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalProperties\"],\n            }) ?? true;\n    }\n}\n;\nexport function parseObjectDefX(def, refs) {\n    Object.keys(def.shape()).reduce((schema, key) => {\n        let prop = def.shape()[key];\n        const isOptional = prop.isOptional();\n        if (!isOptional) {\n            prop = { ...prop._def.innerSchema };\n        }\n        const propSchema = parseDef(prop._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"properties\", key],\n            propertyPath: [...refs.currentPath, \"properties\", key],\n        });\n        if (propSchema !== undefined) {\n            schema.properties[key] = propSchema;\n            if (!isOptional) {\n                if (!schema.required) {\n                    schema.required = [];\n                }\n                schema.required.push(key);\n            }\n        }\n        return schema;\n    }, {\n        type: \"object\",\n        properties: {},\n        additionalProperties: decideAdditionalProperties(def, refs),\n    });\n    const result = {\n        type: \"object\",\n        ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {\n            if (propDef === undefined || propDef._def === undefined)\n                return acc;\n            const parsedDef = parseDef(propDef._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"properties\", propName],\n                propertyPath: [...refs.currentPath, \"properties\", propName],\n            });\n            if (parsedDef === undefined)\n                return acc;\n            return {\n                properties: { ...acc.properties, [propName]: parsedDef },\n                required: propDef.isOptional()\n                    ? acc.required\n                    : [...acc.required, propName],\n            };\n        }, { properties: {}, required: [] }),\n        additionalProperties: decideAdditionalProperties(def, refs),\n    };\n    if (!result.required.length)\n        delete result.required;\n    return result;\n}\nexport function parseObjectDef(def, refs) {\n    const result = {\n        type: \"object\",\n        ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {\n            if (propDef === undefined || propDef._def === undefined)\n                return acc;\n            const parsedDef = parseDef(propDef._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"properties\", propName],\n                propertyPath: [...refs.currentPath, \"properties\", propName],\n            });\n            if (parsedDef === undefined)\n                return acc;\n            return {\n                properties: { ...acc.properties, [propName]: parsedDef },\n                required: propDef.isOptional()\n                    ? acc.required\n                    : [...acc.required, propName],\n            };\n        }, { properties: {}, required: [] }),\n        additionalProperties: decideAdditionalProperties(def, refs),\n    };\n    if (!result.required.length)\n        delete result.required;\n    return result;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseOptionalDef = (def, refs) => {\n    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n        return parseDef(def.innerType._def, refs);\n    }\n    const innerSchema = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n    });\n    return innerSchema\n        ? {\n            anyOf: [\n                {\n                    not: {},\n                },\n                innerSchema,\n            ],\n        }\n        : {};\n};\n","import { parseDef } from \"../parseDef.js\";\nexport const parsePipelineDef = (def, refs) => {\n    if (refs.pipeStrategy === \"input\") {\n        return parseDef(def.in._def, refs);\n    }\n    else if (refs.pipeStrategy === \"output\") {\n        return parseDef(def.out._def, refs);\n    }\n    const a = parseDef(def.in._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    });\n    const b = parseDef(def.out._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n    });\n    return {\n        allOf: [a, b].filter((x) => x !== undefined),\n    };\n};\n","import { parseDef } from \"../parseDef.js\";\nexport function parsePromiseDef(def, refs) {\n    return parseDef(def.type._def, refs);\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseSetDef(def, refs) {\n    const items = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\"],\n    });\n    const schema = {\n        type: \"array\",\n        uniqueItems: true,\n        items,\n    };\n    if (def.minSize) {\n        setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n    }\n    if (def.maxSize) {\n        setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n    }\n    return schema;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseTupleDef(def, refs) {\n    if (def.rest) {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n            additionalItems: parseDef(def.rest._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalItems\"],\n            }),\n        };\n    }\n    else {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            maxItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n        };\n    }\n}\n","export function parseUndefinedDef() {\n    return {\n        not: {},\n    };\n}\n","export function parseUnknownDef() {\n    return {};\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseReadonlyDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { parseDef } from \"./parseDef.js\";\nimport { getRefs } from \"./Refs.js\";\nconst zodToJsonSchema = (schema, options) => {\n    const refs = getRefs(options);\n    const definitions = typeof options === \"object\" && options.definitions\n        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n            ...acc,\n            [name]: parseDef(schema._def, {\n                ...refs,\n                currentPath: [...refs.basePath, refs.definitionPath, name],\n            }, true) ?? {},\n        }), {})\n        : undefined;\n    const name = typeof options === \"string\"\n        ? options\n        : options?.nameStrategy === \"title\"\n            ? undefined\n            : options?.name;\n    const main = parseDef(schema._def, name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n        }, false) ?? {};\n    const title = typeof options === \"object\" &&\n        options.name !== undefined &&\n        options.nameStrategy === \"title\"\n        ? options.name\n        : undefined;\n    if (title !== undefined) {\n        main.title = title;\n    }\n    const combined = name === undefined\n        ? definitions\n            ? {\n                ...main,\n                [refs.definitionPath]: definitions,\n            }\n            : main\n        : {\n            $ref: [\n                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n                refs.definitionPath,\n                name,\n            ].join(\"/\"),\n            [refs.definitionPath]: {\n                ...definitions,\n                [name]: main,\n            },\n        };\n    if (refs.target === \"jsonSchema7\") {\n        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (refs.target === \"jsonSchema2019-09\") {\n        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n    }\n    return combined;\n};\nexport { zodToJsonSchema };\n","import { ZodType } from \"zod\"\nimport { zodToJsonSchema } from \"zod-to-json-schema\"\n\nexport default <T>(data: T, type: ZodType<T>): T => {\n\tconst result = type.safeParse(data)\n\n\tif (result.error) {\n\t\tconsole.error(\n\t\t\t\"Invalid data type, please report to https://github.com/zS1L3NT/ts-npm-ytmusic-api/issues/new/choose\",\n\t\t\tJSON.stringify(\n\t\t\t\t{\n\t\t\t\t\tdata,\n\t\t\t\t\tschema: zodToJsonSchema(type, \"schema\"),\n\t\t\t\t\terror: result.error,\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\t2,\n\t\t\t),\n\t\t)\n\t}\n\n\treturn data\n}\n","export const traverse = (data: any, ...keys: string[]) => {\n\tconst again = (data: any, key: string, deadEnd = false): any => {\n\t\tconst res = []\n\n\t\tif (data instanceof Object && key in data) {\n\t\t\tres.push(data[key])\n\t\t\tif (deadEnd) return res.length === 1 ? res[0] : res\n\t\t}\n\n\t\tif (data instanceof Array) {\n\t\t\tres.push(...data.map(v => again(v, key)).flat())\n\t\t} else if (data instanceof Object) {\n\t\t\tres.push(\n\t\t\t\t...Object.keys(data)\n\t\t\t\t\t.map(k => again(data[k], key))\n\t\t\t\t\t.flat(),\n\t\t\t)\n\t\t}\n\n\t\treturn res.length === 1 ? res[0] : res\n\t}\n\n\tlet value = data\n\tconst lastKey = keys.at(-1)\n\tfor (const key of keys) {\n\t\tvalue = again(value, key, lastKey === key)\n\t}\n\n\treturn value\n}\n\nexport const traverseList = (data: any, ...keys: string[]): any[] => {\n\treturn [traverse(data, ...keys)].flat()\n}\n\nexport const traverseString = (data: any, ...keys: string[]): string => {\n\treturn traverseList(data, ...keys).at(0) || \"\"\n}\n","import { traverseString } from \"./traverse\"\n\nexport const isTitle = (data: any) => {\n\treturn traverseString(data, \"musicVideoType\").startsWith(\"MUSIC_VIDEO_TYPE_\")\n}\n\nexport const isArtist = (data: any) => {\n\treturn [\"MUSIC_PAGE_TYPE_USER_CHANNEL\", \"MUSIC_PAGE_TYPE_ARTIST\"].includes(\n\t\ttraverseString(data, \"pageType\"),\n\t)\n}\n\nexport const isAlbum = (data: any) => {\n\treturn traverseString(data, \"pageType\") === \"MUSIC_PAGE_TYPE_ALBUM\"\n}\n\nexport const isDuration = (data: any) => {\n\treturn traverseString(data, \"text\").match(/(\\d{1,2}:)?\\d{1,2}:\\d{1,2}/)\n}\n","import { ArtistBasic, PlaylistDetailed, PlaylistFull } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { isArtist } from \"../utils/filters\"\nimport { traverse, traverseList, traverseString } from \"../utils/traverse\"\n\nexport default class PlaylistParser {\n\tpublic static parse(data: any, playlistId: string): PlaylistFull {\n\t\tconst artist = traverse(data, \"tabs\", \"straplineTextOne\")\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"PLAYLIST\",\n\t\t\t\tplaylistId,\n\t\t\t\tname: traverseString(data, \"tabs\", \"title\", \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tvideoCount:\n\t\t\t\t\t+traverseList(data, \"tabs\", \"secondSubtitle\", \"text\")\n\t\t\t\t\t\t.at(2)\n\t\t\t\t\t\t.split(\" \")\n\t\t\t\t\t\t.at(0)\n\t\t\t\t\t\t.replaceAll(\",\", \"\") ?? null,\n\t\t\t\tthumbnails: traverseList(data, \"tabs\", \"thumbnails\"),\n\t\t\t},\n\t\t\tPlaylistFull,\n\t\t)\n\t}\n\n\tpublic static parseSearchResult(item: any): PlaylistDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\t// No specific way to identify the title\n\t\tconst title = columns[0]\n\t\tconst artist = columns.find(isArtist) || columns[3]\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"PLAYLIST\",\n\t\t\t\tplaylistId: traverseString(item, \"overlay\", \"playlistId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tPlaylistDetailed,\n\t\t)\n\t}\n\n\tpublic static parseArtistFeaturedOn(item: any, artistBasic: ArtistBasic): PlaylistDetailed {\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"PLAYLIST\",\n\t\t\t\tplaylistId: traverseString(item, \"navigationEndpoint\", \"browseId\"),\n\t\t\t\tname: traverseString(item, \"runs\", \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tPlaylistDetailed,\n\t\t)\n\t}\n\n\tpublic static parseHomeSection(item: any): PlaylistDetailed {\n\t\tconst artist = traverse(item, \"subtitle\", \"runs\")\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"PLAYLIST\",\n\t\t\t\tplaylistId: traverseString(item, \"navigationEndpoint\", \"playlistId\"),\n\t\t\t\tname: traverseString(item, \"runs\", \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tPlaylistDetailed,\n\t\t)\n\t}\n}\n","import { PageType } from \"../constants\"\nimport { AlbumDetailed, HomeSection } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { traverseList, traverseString } from \"../utils/traverse\"\nimport AlbumParser from \"./AlbumParser\"\nimport PlaylistParser from \"./PlaylistParser\"\nimport SongParser from \"./SongParser\"\n\nexport default class Parser {\n\tpublic static parseDuration(time: string) {\n\t\tif (!time) return null\n\n\t\tconst [seconds, minutes, hours] = time\n\t\t\t.split(\":\")\n\t\t\t.reverse()\n\t\t\t.map(n => +n) as (number | undefined)[]\n\n\t\treturn (seconds || 0) + (minutes || 0) * 60 + (hours || 0) * 60 * 60\n\t}\n\n\tpublic static parseNumber(string: string): number {\n\t\tif (string.at(-1)!.match(/^[A-Z]+$/)) {\n\t\t\tconst number = +string.slice(0, -1)\n\t\t\tconst multiplier = string.at(-1)\n\n\t\t\treturn (\n\t\t\t\t{\n\t\t\t\t\tK: number * 1000,\n\t\t\t\t\tM: number * 1000 * 1000,\n\t\t\t\t\tB: number * 1000 * 1000 * 1000,\n\t\t\t\t\tT: number * 1000 * 1000 * 1000 * 1000,\n\t\t\t\t}[multiplier!] || NaN\n\t\t\t)\n\t\t} else {\n\t\t\treturn +string\n\t\t}\n\t}\n\n\tpublic static parseHomeSection(data: any): HomeSection {\n\t\tconst pageType = traverseString(data, \"contents\", \"title\", \"browseEndpoint\", \"pageType\")\n\t\tconst playlistId = traverseString(\n\t\t\tdata,\n\t\t\t\"navigationEndpoint\",\n\t\t\t\"watchPlaylistEndpoint\",\n\t\t\t\"playlistId\",\n\t\t)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttitle: traverseString(data, \"header\", \"title\", \"text\"),\n\t\t\t\tcontents: traverseList(data, \"contents\").map(item => {\n\t\t\t\t\tswitch (pageType) {\n\t\t\t\t\t\tcase PageType.MUSIC_PAGE_TYPE_ALBUM:\n\t\t\t\t\t\t\treturn AlbumParser.parseHomeSection(item)\n\t\t\t\t\t\tcase PageType.MUSIC_PAGE_TYPE_PLAYLIST:\n\t\t\t\t\t\t\treturn PlaylistParser.parseHomeSection(item)\n\t\t\t\t\t\tcase \"\":\n\t\t\t\t\t\t\tif (playlistId) {\n\t\t\t\t\t\t\t\treturn PlaylistParser.parseHomeSection(item)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn SongParser.parseHomeSection(item)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn null as unknown as AlbumDetailed\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t},\n\t\t\tHomeSection,\n\t\t)\n\t}\n}\n","import { AlbumBasic, ArtistBasic, SongDetailed, SongFull, ThumbnailFull } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { isAlbum, isArtist, isDuration, isTitle } from \"../utils/filters\"\nimport { traverseList, traverseString } from \"../utils/traverse\"\nimport Parser from \"./Parser\"\n\nexport default class SongParser {\n\tpublic static parse(data: any): SongFull {\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"SONG\",\n\t\t\t\tvideoId: traverseString(data, \"videoDetails\", \"videoId\"),\n\t\t\t\tname: traverseString(data, \"videoDetails\", \"title\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(data, \"author\"),\n\t\t\t\t\tartistId: traverseString(data, \"videoDetails\", \"channelId\"),\n\t\t\t\t},\n\t\t\t\tduration: +traverseString(data, \"videoDetails\", \"lengthSeconds\"),\n\t\t\t\tthumbnails: traverseList(data, \"videoDetails\", \"thumbnails\"),\n\t\t\t\tformats: traverseList(data, \"streamingData\", \"formats\"),\n\t\t\t\tadaptiveFormats: traverseList(data, \"streamingData\", \"adaptiveFormats\"),\n\t\t\t},\n\t\t\tSongFull,\n\t\t)\n\t}\n\n\tpublic static parseSearchResult(item: any): SongDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\")\n\n\t\t// It is not possible to identify the title and author\n\t\tconst title = columns[0]\n\t\tconst artist = columns.find(isArtist) || columns[3]\n\t\tconst album = columns.find(isAlbum) ?? null\n\t\tconst duration = columns.find(isDuration)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"SONG\",\n\t\t\t\tvideoId: traverseString(item, \"playlistItemData\", \"videoId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\talbum: album\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tname: traverseString(album, \"text\"),\n\t\t\t\t\t\t\talbumId: traverseString(album, \"browseId\"),\n\t\t\t\t\t\t}\n\t\t\t\t\t: null,\n\t\t\t\tduration: Parser.parseDuration(duration?.text),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tSongDetailed,\n\t\t)\n\t}\n\n\tpublic static parseArtistSong(item: any, artistBasic: ArtistBasic): SongDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\tconst title = columns.find(isTitle)\n\t\tconst album = columns.find(isAlbum)\n\t\tconst duration = columns.find(isDuration)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"SONG\",\n\t\t\t\tvideoId: traverseString(item, \"playlistItemData\", \"videoId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\talbum: album\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tname: traverseString(album, \"text\"),\n\t\t\t\t\t\t\talbumId: traverseString(album, \"browseId\"),\n\t\t\t\t\t\t}\n\t\t\t\t\t: null,\n\t\t\t\tduration: Parser.parseDuration(duration?.text),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tSongDetailed,\n\t\t)\n\t}\n\n\tpublic static parseArtistTopSong(item: any, artistBasic: ArtistBasic): SongDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\tconst title = columns.find(isTitle)\n\t\tconst album = columns.find(isAlbum)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"SONG\",\n\t\t\t\tvideoId: traverseString(item, \"playlistItemData\", \"videoId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\talbum: {\n\t\t\t\t\tname: traverseString(album, \"text\"),\n\t\t\t\t\talbumId: traverseString(album, \"browseId\"),\n\t\t\t\t},\n\t\t\t\tduration: null,\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tSongDetailed,\n\t\t)\n\t}\n\n\tpublic static parseAlbumSong(\n\t\titem: any,\n\t\tartistBasic: ArtistBasic,\n\t\talbumBasic: AlbumBasic,\n\t\tthumbnails: ThumbnailFull[],\n\t): SongDetailed {\n\t\tconst title = traverseList(item, \"flexColumns\", \"runs\").find(isTitle)\n\t\tconst duration = traverseList(item, \"fixedColumns\", \"runs\").find(isDuration)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"SONG\",\n\t\t\t\tvideoId: traverseString(item, \"playlistItemData\", \"videoId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\talbum: albumBasic,\n\t\t\t\tduration: Parser.parseDuration(duration?.text),\n\t\t\t\tthumbnails,\n\t\t\t},\n\t\t\tSongDetailed,\n\t\t)\n\t}\n\n\tpublic static parseHomeSection(item: any) {\n\t\treturn SongParser.parseSearchResult(item)\n\t}\n}\n","import { AlbumBasic, AlbumDetailed, AlbumFull, ArtistBasic } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { isArtist } from \"../utils/filters\"\nimport { traverse, traverseList, traverseString } from \"../utils/traverse\"\nimport SongParser from \"./SongParser\"\n\nexport default class AlbumParser {\n\tpublic static parse(data: any, albumId: string): AlbumFull {\n\t\tconst albumBasic: AlbumBasic = {\n\t\t\talbumId,\n\t\t\tname: traverseString(data, \"tabs\", \"title\", \"text\"),\n\t\t}\n\n\t\tconst artistData = traverse(data, \"tabs\", \"straplineTextOne\", \"runs\")\n\t\tconst artistBasic: ArtistBasic = {\n\t\t\tartistId: traverseString(artistData, \"browseId\") || null,\n\t\t\tname: traverseString(artistData, \"text\"),\n\t\t}\n\n\t\tconst thumbnails = traverseList(data, \"background\", \"thumbnails\")\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ALBUM\",\n\t\t\t\t...albumBasic,\n\t\t\t\tplaylistId: traverseString(data, \"musicPlayButtonRenderer\", \"playlistId\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\tyear: AlbumParser.processYear(\n\t\t\t\t\ttraverseList(data, \"tabs\", \"subtitle\", \"text\").at(-1),\n\t\t\t\t),\n\t\t\t\tthumbnails,\n\t\t\t\tsongs: traverseList(data, \"musicResponsiveListItemRenderer\").map(item =>\n\t\t\t\t\tSongParser.parseAlbumSong(item, artistBasic, albumBasic, thumbnails),\n\t\t\t\t),\n\t\t\t},\n\t\t\tAlbumFull,\n\t\t)\n\t}\n\n\tpublic static parseSearchResult(item: any): AlbumDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\t// No specific way to identify the title\n\t\tconst title = columns[0]\n\t\tconst artist = columns.find(isArtist) || columns[3]\n\t\tconst playlistId =\n\t\t\ttraverseString(item, \"overlay\", \"playlistId\") ||\n\t\t\ttraverseString(item, \"thumbnailOverlay\", \"playlistId\")\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ALBUM\",\n\t\t\t\talbumId: traverseList(item, \"browseId\").at(-1),\n\t\t\t\tplaylistId,\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tyear: AlbumParser.processYear(columns.at(-1)?.text),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tAlbumDetailed,\n\t\t)\n\t}\n\n\tpublic static parseArtistAlbum(item: any, artistBasic: ArtistBasic): AlbumDetailed {\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ALBUM\",\n\t\t\t\talbumId: traverseList(item, \"browseId\").at(-1),\n\t\t\t\tplaylistId: traverseString(item, \"thumbnailOverlay\", \"playlistId\"),\n\t\t\t\tname: traverseString(item, \"title\", \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\tyear: AlbumParser.processYear(traverseList(item, \"subtitle\", \"text\").at(-1)),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tAlbumDetailed,\n\t\t)\n\t}\n\n\tpublic static parseArtistTopAlbum(item: any, artistBasic: ArtistBasic): AlbumDetailed {\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ALBUM\",\n\t\t\t\talbumId: traverseList(item, \"browseId\").at(-1),\n\t\t\t\tplaylistId: traverseString(item, \"musicPlayButtonRenderer\", \"playlistId\"),\n\t\t\t\tname: traverseString(item, \"title\", \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\tyear: AlbumParser.processYear(traverseList(item, \"subtitle\", \"text\").at(-1)),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tAlbumDetailed,\n\t\t)\n\t}\n\n\tpublic static parseHomeSection(item: any): AlbumDetailed {\n\t\tconst artist = traverse(item, \"subtitle\", \"runs\").at(-1)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ALBUM\",\n\t\t\t\talbumId: traverseString(item, \"title\", \"browseId\"),\n\t\t\t\tplaylistId: traverseString(item, \"thumbnailOverlay\", \"playlistId\"),\n\t\t\t\tname: traverseString(item, \"title\", \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tyear: null,\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tAlbumDetailed,\n\t\t)\n\t}\n\n\tprivate static processYear(year: string) {\n\t\treturn year && year.match(/^\\d{4}$/) ? +year : null\n\t}\n}\n","import { ArtistBasic, VideoDetailed, VideoFull } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { isArtist, isDuration, isTitle } from \"../utils/filters\"\nimport { traverse, traverseList, traverseString } from \"../utils/traverse\"\nimport Parser from \"./Parser\"\n\nexport default class VideoParser {\n\tpublic static parse(data: any): VideoFull {\n\t\treturn {\n\t\t\ttype: \"VIDEO\",\n\t\t\tvideoId: traverseString(data, \"videoDetails\", \"videoId\"),\n\t\t\tname: traverseString(data, \"videoDetails\", \"title\"),\n\t\t\tartist: {\n\t\t\t\tartistId: traverseString(data, \"videoDetails\", \"channelId\"),\n\t\t\t\tname: traverseString(data, \"author\"),\n\t\t\t},\n\t\t\tduration: +traverseString(data, \"videoDetails\", \"lengthSeconds\"),\n\t\t\tthumbnails: traverseList(data, \"videoDetails\", \"thumbnails\"),\n\t\t\tunlisted: traverse(data, \"unlisted\"),\n\t\t\tfamilySafe: traverse(data, \"familySafe\"),\n\t\t\tpaid: traverse(data, \"paid\"),\n\t\t\ttags: traverseList(data, \"tags\"),\n\t\t}\n\t}\n\n\tpublic static parseSearchResult(item: any): VideoDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\tconst title = columns.find(isTitle)\n\t\tconst artist = columns.find(isArtist) || columns[1]\n\t\tconst duration = columns.find(isDuration)\n\n\t\treturn {\n\t\t\ttype: \"VIDEO\",\n\t\t\tvideoId: traverseString(item, \"playNavigationEndpoint\", \"videoId\"),\n\t\t\tname: traverseString(title, \"text\"),\n\t\t\tartist: {\n\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t},\n\t\t\tduration: Parser.parseDuration(duration?.text),\n\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t}\n\t}\n\n\tpublic static parseArtistTopVideo(item: any, artistBasic: ArtistBasic): VideoDetailed {\n\t\treturn {\n\t\t\ttype: \"VIDEO\",\n\t\t\tvideoId: traverseString(item, \"videoId\"),\n\t\t\tname: traverseString(item, \"runs\", \"text\"),\n\t\t\tartist: artistBasic,\n\t\t\tduration: null,\n\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t}\n\t}\n\n\tpublic static parsePlaylistVideo(item: any): VideoDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\tconst title = columns.find(isTitle) || columns[0]\n\t\tconst artist = columns.find(isArtist) || columns[1]\n\t\tconst duration = columns.find(isDuration)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"VIDEO\",\n\t\t\t\tvideoId:\n\t\t\t\t\ttraverseString(item, \"playNavigationEndpoint\", \"videoId\") ||\n\t\t\t\t\ttraverseList(item, \"thumbnails\")[0].url.match(\n\t\t\t\t\t\t/https:\\/\\/i\\.ytimg\\.com\\/vi\\/(.+)\\//,\n\t\t\t\t\t)[1],\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tduration: Parser.parseDuration(duration?.text),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tVideoDetailed,\n\t\t)\n\t}\n}\n","import { ArtistDetailed, ArtistFull } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { traverseList, traverseString } from \"../utils/traverse\"\nimport AlbumParser from \"./AlbumParser\"\nimport PlaylistParser from \"./PlaylistParser\"\nimport SongParser from \"./SongParser\"\nimport VideoParser from \"./VideoParser\"\n\nexport default class ArtistParser {\n\tpublic static parse(data: any, artistId: string): ArtistFull {\n\t\tconst artistBasic = {\n\t\t\tartistId,\n\t\t\tname: traverseString(data, \"header\", \"title\", \"text\"),\n\t\t}\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ARTIST\",\n\t\t\t\t...artistBasic,\n\t\t\t\tthumbnails: traverseList(data, \"header\", \"thumbnails\"),\n\t\t\t\ttopSongs: traverseList(data, \"musicShelfRenderer\", \"contents\").map(item =>\n\t\t\t\t\tSongParser.parseArtistTopSong(item, artistBasic),\n\t\t\t\t),\n\t\t\t\ttopAlbums:\n\t\t\t\t\ttraverseList(data, \"musicCarouselShelfRenderer\")\n\t\t\t\t\t\t?.at(0)\n\t\t\t\t\t\t?.contents.map((item: any) =>\n\t\t\t\t\t\t\tAlbumParser.parseArtistTopAlbum(item, artistBasic),\n\t\t\t\t\t\t) ?? [],\n\t\t\t\ttopSingles:\n\t\t\t\t\ttraverseList(data, \"musicCarouselShelfRenderer\")\n\t\t\t\t\t\t?.at(1)\n\t\t\t\t\t\t?.contents.map((item: any) =>\n\t\t\t\t\t\t\tAlbumParser.parseArtistTopAlbum(item, artistBasic),\n\t\t\t\t\t\t) ?? [],\n\t\t\t\ttopVideos:\n\t\t\t\t\ttraverseList(data, \"musicCarouselShelfRenderer\")\n\t\t\t\t\t\t?.at(2)\n\t\t\t\t\t\t?.contents.map((item: any) =>\n\t\t\t\t\t\t\tVideoParser.parseArtistTopVideo(item, artistBasic),\n\t\t\t\t\t\t) ?? [],\n\t\t\t\tfeaturedOn:\n\t\t\t\t\ttraverseList(data, \"musicCarouselShelfRenderer\")\n\t\t\t\t\t\t?.at(3)\n\t\t\t\t\t\t?.contents.map((item: any) =>\n\t\t\t\t\t\t\tPlaylistParser.parseArtistFeaturedOn(item, artistBasic),\n\t\t\t\t\t\t) ?? [],\n\t\t\t\tsimilarArtists:\n\t\t\t\t\ttraverseList(data, \"musicCarouselShelfRenderer\")\n\t\t\t\t\t\t?.at(4)\n\t\t\t\t\t\t?.contents.map((item: any) => this.parseSimilarArtists(item)) ?? [],\n\t\t\t},\n\t\t\tArtistFull,\n\t\t)\n\t}\n\n\tpublic static parseSearchResult(item: any): ArtistDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\t// No specific way to identify the title\n\t\tconst title = columns[0]\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ARTIST\",\n\t\t\t\tartistId: traverseString(item, \"browseId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tArtistDetailed,\n\t\t)\n\t}\n\n\tpublic static parseSimilarArtists(item: any): ArtistDetailed {\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ARTIST\",\n\t\t\t\tartistId: traverseString(item, \"browseId\"),\n\t\t\t\tname: traverseString(item, \"runs\", \"text\"),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tArtistDetailed,\n\t\t)\n\t}\n}\n","import { SearchResult } from \"../types\"\nimport { traverseList } from \"../utils/traverse\"\nimport AlbumParser from \"./AlbumParser\"\nimport ArtistParser from \"./ArtistParser\"\nimport PlaylistParser from \"./PlaylistParser\"\nimport SongParser from \"./SongParser\"\nimport VideoParser from \"./VideoParser\"\n\nexport default class SearchParser {\n\tpublic static parse(item: any): SearchResult | null {\n\t\tconst flexColumns = traverseList(item, \"flexColumns\")\n\t\tconst type = traverseList(flexColumns[1], \"runs\", \"text\").at(0) as\n\t\t\t| \"Song\"\n\t\t\t| \"Video\"\n\t\t\t| \"Artist\"\n\t\t\t| \"EP\"\n\t\t\t| \"Single\"\n\t\t\t| \"Album\"\n\t\t\t| \"Playlist\"\n\n\t\tconst parsers = {\n\t\t\tSong: SongParser.parseSearchResult,\n\t\t\tVideo: VideoParser.parseSearchResult,\n\t\t\tArtist: ArtistParser.parseSearchResult,\n\t\t\tEP: AlbumParser.parseSearchResult,\n\t\t\tSingle: AlbumParser.parseSearchResult,\n\t\t\tAlbum: AlbumParser.parseSearchResult,\n\t\t\tPlaylist: PlaylistParser.parseSearchResult,\n\t\t}\n\n\t\tif (parsers[type]) {\n\t\t\treturn parsers[type](item)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n}\n","import YTMusic from \"./YTMusic\"\n\nexport type {\n\tAlbumBasic,\n\tAlbumDetailed,\n\tAlbumFull,\n\tArtistBasic,\n\tArtistDetailed,\n\tArtistFull,\n\tPlaylistDetailed,\n\tPlaylistFull,\n\tSearchResult,\n\tSongDetailed,\n\tSongFull,\n\tThumbnailFull,\n\tVideoDetailed,\n\tVideoFull,\n\tHomeSection,\n} from \"./types\"\n\nexport default YTMusic\n"]}